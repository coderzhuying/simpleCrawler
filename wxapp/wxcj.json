{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "author": "Rolan", "pub_time": "2018-7-30 00:12", "content": "小程序全局配置app.josn增加选项：\"navigationStyle\": \"custom\",具体如下：原生小程序开发打开 app.json：{    \"pages\": [        \"pages/index/index\",        \"pages/logs/index\"    ],    \"window\": {        \"backgroundTextStyle\": \"light\",        \"navigationBarBackgroundColor\": \"#000\",        \"navigationStyle\": \"custom\",        \"navigationBarTitleText\": \"WeChat\"    }}mpvue方式开发小程序>打开 /src/main.js：export default {  config: {    pages: [      'pages/logs/main',      '^pages/index/main'　　],    window: {      backgroundTextStyle: 'light',      navigationBarBackgroundColor: '#666',      navigationStyle: 'custom',      navigationBarTitleText: 'WeChat',      navigationBarTextStyle: '#fff',      enablePullDownRefresh: false,      disableScroll: true    }  }}"}
{"title": "小程序 textarea组件层级过高导致文字穿透浮层的一个解决方法 ... ... ", "author": "Rolan", "pub_time": "2018-8-13 00:19", "content": "最近做的一个小程序需求，其中一个页面使用到了 textarea这个小程序组件，然后点击页面上的某个元素，会触发页面弹起一个弹窗，这时发现 textarea的 placeholder文字或者输入的文字内容，会直接穿透遮罩层和浮动弹窗，显示在最上面，开始时我以为是遮罩层和浮动弹窗的层级舍得小了，于是改大，谁知道没用，改到了 99999也没用，于是我意识到这应该不是我代码的问题，网上一搜，果然有故事。\r\n\r\n解决方案\r\n\r\n隐藏 textarea\r\n\r\n这是最简单的解决手段，一般弹窗的时候，都会带个遮罩层，把遮罩层下面的内容隐藏一部分，用户基本上不会注意的，然后再去掉弹窗和遮罩层的时候再把 textarea显示出来。\r\n这种方法简单有效，大部分情况下都可以这么解决。\r\n<textarea wx:if=\"{{ showMask }}\">textarea>\r\n复制代码\r\n使用替代元素\r\n\r\n有时候， textarea穿透的不是遮罩层，或者遮罩层以一种半透明而非完全遮住页面内容的形式呈现，担心用户能够看到因为 textarea的消失而导致页面跳动，产生不好的用户体验，那么就可以使用替代元素来替代 textarea而非将之直接隐藏掉。\r\n基本的 textarea组件只接受文本的输入，抛开可输入性的话，外观上看就是一个含有文本节点的简单元素，只需要获取当前状态下的 textarea中输入的文字，将之赋予给一个样式与 textarea相同的普通元素，就达到了临时替代的效果。\r\n\r\n<textarea id=\"text-area\" value=\"{{txtRealContent}}\" bindinput='txtInput' wx:if=\"{{!showMask}}\" />\r\n\r\n<view class='rich-text' style=\"{{('height:' + txtHeight + 'px')}}\" wx:else>\r\n  <rich-text nodes=\"{{txtRealContent}}\">rich-text>\r\nview>\r\n复制代码如上所示\r\n\r\n由于需要实时获取 textarea中已经输入的内容，所以给 textarea元素加了个 bindinput的监听器\r\nshowMask用于标识是否显示遮罩层(或者其他可能会被 textarea穿透的浮动元素)，如果显示遮罩层，则隐藏 textarea元素，并显示替代原宿\r\n这里 textarea的隐藏使用了 wx:if，会使其彻底地从页面中消失，而重新显示出来的时候，textarea元素会重新创建，丢失原先输入，所以给其加了个 value属性，其值 txtRealContent就是缓存的 textarea已经输入的文本内容；如果你不用这种方法，不让 textarea完全显示，而仅仅是隐藏，例如使用 hidden=\"{{ showMask ? true :false }}\"，因为不涉及到 textarea的删除与重建，所以就无需添加 value属性来控制文本内容了。\r\ntextarea是可以输入可换行的文本内容的，所以这里使用了 rich-text组件，在使用的时候，我发现 rich-text好像不支持溢出隐藏，所以又额外在其外面包了一层 view组件，并将其高度设置为和 textarea相同\r\n\r\n上面四个步骤，都比较简单，稍微需要注意的是，如果 textarea的内容包含了换行文本，则需要对换行符进行处理：\r\ntextareaContent.replace(/\\n/g, '')\r\n复制代码如果你想让 textarea自动增加高度而不是固定高度，给 textarea加了个 auto-height，那么就需要“实时”获取其高度\r\n说是 “实时”，其实也并不是那么实时，不考虑其他样式的变化， textarea的高度与行数有关，每增减一行，其高度才会变化，所以只需要监控其内容行数的变化即可，恰好 textarea组件也已经提供了这个监控器：bindlinechange。\r\n\r\n\r\n原理说完了，完整实例代码如下：\r\nindex.wxml\r\n<view class=\"page-body\">\r\n  <button bindtap=\"changeMaskVisible\">切换maskbutton>\r\n  <view class=\"textarea-wrp\">\r\n    <textarea id=\"text-area\" value=\"{{txtContent}}\" bindinput='txtInput' bindlinechange=\"textAreaLineChange\" wx:if=\"{{!showMask}}\" auto-height />\r\n    <view class='rich-text' style=\"{{('height:' + txtHeight + 'px')}}\" wx:else>\r\n      <rich-text nodes=\"{{txtRealContent}}\">rich-text>\r\n    view>\r\n  view>\r\n  <button>Footerbutton>\r\n  <view wx:if=\"{{showMask}}\" bindtap=\"changeMaskVisible\" class=\"mask\">\r\n    <view class=\"mask-content\">view>    \r\n  view>\r\nview>\r\n复制代码index.js\r\nPage({\r\n  data: {\r\n    txtRealContent: '',\r\n    txtContent: '',\r\n    showMask: false,\r\n    txtHeight: 0\r\n  },\r\n  textAreaLineChange(e) {\r\n    this.setData({ txtHeight: e.detail.height })\r\n  },\r\n  txtInput(e) {\r\n    this.setData({ txtContent: e.detail.value })\r\n  },\r\n  changeMaskVisible(e) {\r\n    if (!this.data.showMask) {\r\n      // 将换行符转换为wxml可识别的换行元素 \r\n      const txtRealContent = this.data.txtContent.replace(/\\n/g, '')\r\n      this.setData({ txtRealContent })\r\n    }\r\n    this.setData({ showMask: !this.data.showMask })\r\n  }\r\n})\r\n复制代码index.wxss\r\n.rich-text {\r\n  overflow: hidden;\r\n}\r\n.mask {\r\n  position: fixed;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  background-color: rgba(0, 0, 0, .6);\r\n  z-index: 10;\r\n}\r\n.mask-content {\r\n  position: fixed;\r\n  top: 44%;\r\n  left: 50%;\r\n  height: 60%;\r\n  width: 60%;\r\n  transform: translate(-50%, -50%);\r\n  background-color: yellowgreen;\r\n  z-index: 12;\r\n}作者：清夜链接：https://juejin.im/post/5b6ab1f951882539766ea558"}
{"title": "微信小程序实现常见的user效果 ", "author": "Rolan", "pub_time": "2018-8-13 00:25", "content": "用户个人页面 为了便于以后的使用，所以把这个效果记录下来，以后直接复制粘贴本篇的代码。wxml<view class='circle'>    <view class='userAvatar'>      <open-data type=\"userAvatarUrl\" ></open-data>    </view>  </view>代码说明： open-data没有办法直接给一个class然后控制类名，但是可以通过控制外部盒子达到控制它本身的大小以及形状的目的。wxss.circle{  width:930rpx;  height:930rpx;  border-radius:465rpx;  background-color:#2ca6cb;  margin-top:-666rpx;  margin-left:-90rpx;  display:flex;  align-items:center;  flex-direction:column-reverse;}.userAvatar{  width:80px;  height:80px;  border-radius:40px;  margin-bottom:-30px;  overflow: hidden;}说明：通过flex布局控制头像的位置。作者：王月_92f2 链接：https://www.jianshu.com/p/b2fd8ae61660"}
{"title": "微信小程序开发-保存服务端sessionid的方法 ", "author": "Rolan", "pub_time": "2018-4-12 00:36", "content": "普通的Web开发，都是把sessionid保存在cookie中传递的。不管是java还是php，服务端的会在response的header中加上Set-CookieResponse HeadersContent-Type:application/json;charset=UTF-8Date:Mon, 02 Apr 2018 16:02:42 GMTSet-Cookie:JSESSIONID=781C7F500DFA24D663BA243A4D9044BC;path=/yht;HttpOnly浏览器的请求也会在header中加上Request HeadersAccept:*/*Accept-Encoding:gzip, deflate, brAccept-Language:zh-CN,zh;q=0.8Cache-Control:no-cacheConnection:keep-aliveContent-Length:564content-type:application/jsonCookie:JSESSIONID=781C7F500DFA24D663BA243A4D9044BC;path=/yht;HttpOnly通过这个sessionid就能使浏览器端和服务端保持会话，使浏览器端保持登录状态但是，微信小程序不能保存Cookie，导致每次wx.request到服务端都会创建一个新的会话，小程序端就不能保持登录状态了简单的处理方法如下：1、把服务端response的Set-Cookie中的值保存到Storage中wx.request({    url: path,    method:method,    header: header,    data:data,    success:function(res){        if(res && res.header && res.header['Set-Cookie']){            wx.setStorageSync('cookieKey', res.header['Set-Cookie']);//保存Cookie到Storage          }},    fail:fail  })wx.request再从Storage中取出Cookie,封装到header中  let cookie = wx.getStorageSync('cookieKey');  let path=conf.baseurl+url;  let header = { };  if(cookie){    header.Cookie=cookie;  }  wx.request({    url: path,    method:method,    header: header,    data:data,    success:success,    fail:fail  })"}
{"title": "微信小程序开发一些经验 ", "author": "Rolan", "pub_time": "2018-5-16 00:14", "content": "对于微信小程序开发入门，还是比较简单的，只需要具备基本的css+js知识就可以了，成本比较低。 写了小程序和RN之后，有一种原生很笨重的感觉，就是小程序或者是RN等这些新的开发方式在效率上面真的有比较大的优势，唯一不足就是运行速度了(使用Canvas就会有这样子的感觉)。 感觉目前所接触的种类前端开发(包括移动端)，都是基本一个套路：UI，网络，数据保存，富文本，图片/视频。 本文也是从这几个方向去总结自己的小程序开发经验。小程序的入门其实小程序的开发过程一直都是查看文档，按照文档去操作就可以了。 一般流程是先看简易教程。看完之后，再去看组件。之后可以开始尝试写需求，这个过程中，开始不断的去查API和框架即可。多列列表在开发中，有一个需求是需要实现类似Android的GridView网格列表的。但是微信中并没有提供这样子的组件，但是小程序是跟html/css前端很类似的，他可以通过指定 display:flex ，然后去设置 flex-wrap:wrap 就可以。例如，有一个数组 data:[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\"] 需要显示为一个三列的列表，可以如下处理：//GridPage.wxml\r\n<view class='grid-container'>\r\n  <view wx:for=\"{{data}}\" wx:key=\"{{item}}\" class=\"grid-list\">\r\n  <view class='grid-item'>\r\n  <text class='grid-item-text'>{{item}}</text>\r\n  </view>\r\n  </view>\r\n</view>\r\n\r\n//GridPage.wxss\r\nPage {\r\n  min-height: 100%;\r\n  background-color: #fff;\r\n}\r\n.grid-container {\r\n  margin-left: 4rpx;\r\n  margin-right: 4rpx;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  flex-direction: row;\r\n}\r\n.grid-list {\r\n  width: 33.33%;\r\n}\r\n.grid-item {\r\n  margin: 2rpx;\r\n  background: #999;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.grid-item-text {\r\n  color: black;\r\n}这里的重点就是 grid-container 中的 flex-wrap 为 wrap ，方向是 row 了。然后他的每一个item宽度都是 33.33% 。需要注意的是一定是去设置外部的contanier而不是内部的list。层级布局在CSS中，需要使用层级布局，就是类似Android的FrameLayout效果，可以使用z-index，也可以使用一个绝对定位。比如，我们有一个需求是：下面是一个图片，上面是文字。//PositionPage.wxml\r\n<view class='root'>\r\n<image src='https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3756982450,995202616&fm=27&gp=0.jpg' class='image'></image>\r\n<text class='text'>我是权律二啊</text>\r\n</view>\r\n//PositionPage.wcss\r\n.root{\r\n  align-items: center;\r\n  display: flex;\r\n  flex-direction: column;\r\n  position: relative;\r\n}\r\n.image{\r\n  width: 300rpx;\r\n  height: 300rpx;\r\n}\r\n.text{\r\n  background-color: #999;\r\n  position: absolute;\r\n}主要是两点：父布局的 position 必须是 relative ，它本身 position 必须是 absolute。网络请求小程序的网络请求是使用wx.request()方法，但是该方法太臃肿，并没有使用Promise那样子简洁。幸运的是小程序支持Promise，所以我们可以把http封装一下，变成有条理。说到这里，大家做的时候需要注意去微信后台配置各种request域名，upload域名，downloadFIle域名。 下面封装的例子的数据返回格式都是json格式post请求方式发出的://真正发起请求\r\nfunction _request(url, param) {\r\n    if (isDebug) {\r\n        Log.i(\"http==> params->\" + JSON.stringify(param));\r\n        Log.i(\"http==> url->\" + url);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url: url,\r\n            data: param,\r\n            header: {\r\n                'content-type': 'application/json',\r\n                \"Accept\": \"application/json\"\r\n            },\r\n            method: \"POST\",\r\n            success: function (response) {\r\n                if (isDebug) {\r\n                    const jsonResponse = JSON.stringify(response);\r\n                    Log.i(\"http==> response->\" + jsonResponse);\r\n                }\r\n                const {data, statusCode, ok = false} = response;\r\n                //只有ok为true的是时候才返回成功，data不一定是包含数据的\r\n                if (statusCode === 200 && data && data.ok) {\r\n                    resolve(data, ok);\r\n                } else {\r\n                    if (statusCode != 404 && statusCode < 500 && statusCode > 300) {\r\n                        ToastUtil.showError();\r\n                    }\r\n                    reject(data);\r\n                }\r\n            },\r\n            fail: reject\r\n        });\r\n    });\r\n\r\n}使用：function getInfo(fid) {\r\n    const params = {};\r\n    params.token = user.token;\r\n    params.uid = user.uid;\r\n    return _request(\"INFO_URL\", params);\r\n}然后需要发起请求就调用该方法即可，处理Promise。上传图片到阿里云需要注意微信upload接口配置目前好像不可以直接配置阿里云的URL，需要阿里云先 跟我们的域名绑定，之后再去把设置到微信后台的upload接口中。可以参考博客： 小程序图片上传阿里OSS使用方法 ，获取签名阿里云Demo地址： JavaScript客户端签名直传 ，通过打log获得policy和signature（签名时间可以稍微设置久一点）之后，就开始封装upload方法了。 如下：/**\r\n    * 真实上传代码\r\n    */\r\n    function _upload(file, success, fail) {\r\n        const suffix = file.substring(file.lastIndexOf(\".\"));\r\n        //做一下md5处理\r\n        const fileName = hex_md5(file);\r\n        Log.i(\"fileName=\" + (fileName + suffix));\r\n        wx.uploadFile({\r\n            url: ALIYUNPHOTOADDRESS,\r\n            formData: {\r\n                \"OSSAccessKeyId\": \"你的阿里云accessKey\",\r\n                \"key\": DIR+ (fileName + suffix),\r\n                \"policy\": \"你的policy\",\r\n                \"success_action_status\": '200',\r\n                \"signature\": \"你的signature\"\r\n            },\r\n            filePath: file,\r\n            name: 'file',\r\n            success: function (res) {\r\n                const {statusCode} = res;\r\n                if (statusCode === 200) {\r\n                    console.log(JSON.stringify(res));\r\n                    success(\"\" + fileName + suffix);\r\n                } else {\r\n                    console.log(\"上传失败\");\r\n                    fail(res);\r\n                }\r\n            },\r\n            fail: function (e) {\r\n                fail(e);\r\n                console.log(\"上传失败\");\r\n                console.log(\"e=\" + JSON.stringify(e));\r\n            }, complete: function () {\r\n                console.log(\"上传过程结束\");\r\n            }\r\n        })\r\n    }\r\n\r\n}其中 url 是上传OOS的地址，key是需要上传的文件夹+上传之后的文件名。这里的fileName我们通过一个md5去计算得来，保证唯一性又没有什么特殊字符。md5的算法来自JS-MD5加密。我们可以顺带封装一个上传多张图片的方法,而且使用Promise返回：/**\r\n* files需要上传的文件，是一个数组,里面是文件的绝对路径\r\n*/\r\nfunction uploadFiles(files) {\r\n  if (!files || files.length <= 0) {\r\n    wx.showModal({\r\n      title: '图片错误',\r\n      content: '请重试',\r\n      showCancel: false,\r\n    });\r\n    return Promise.reject();\r\n  }\r\n  Log.i(\"开始上传\" + files);\r\n\r\n  return new Promise((resolve, reject) => {\r\n    //上传成功的文件名称\r\n    let uploadPaths = [];\r\n    for (let i = 0; i < files.length; i++) {\r\n      _upload(files[i], (path) => {\r\n        //成功的文件名\r\n        uploadPaths[uploadPaths.length] = path;\r\n        if (uploadPaths.length >= files.length) {\r\n          //把url+name返回\r\n          resolve([ALIYUNPHOTOADDRESS + \"/\" +DIR, uploadPaths]);\r\n        }\r\n      }, () => {\r\n        //error\r\n        reject(res);\r\n      });\r\n    }\r\n\r\n  });Canvas使用由于需要使用Canvas画一棵树，所以还是在这里走了比较多的坑的。我的需求是Canvas全屏，除了画一个树之外还需要画别的一些独立Button。 首先，设置Canvas全屏和不可滑动，可以通过以下方式：<canvas  disable-scroll='true' style=\"width: {{width}}px; height: {{height}}px;background-color:#efeff4;flex:1;\" canvas-id=\"canvas\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\" bindtouchend=\"touchEnd\"></canvas>其中，在设置了disable-scroll设置为true，同时需要绑定三个touch事件，才能响应画布的触摸event。其中这里的width+height是通过wx.getSystemInfo()获得。其次，canvas没有类似View的catchtap事件，只有一些touch事件，详情可以看Canvas然后在微信小程序中Canvas是层级最高的，无法通过设置z-index去调，所以假如你的Canvas全屏，还需要一些其他的Button，那么只能通过最后canvas去draw了。在canvas中，假如通过moveTo+lineTo去画线，一般需要先调用canvas.beginPath()画完成之后，先调用canvas.stoke()，然后在调用canvas.closePath();c.beginPath();\r\n    c.setLineWidth(this.arrowPaint.width);\r\n    c.setStrokeStyle(this.arrowPaint.color);\r\n    c.setLineCap(\"square\");\r\n\r\n    c.moveTo(this.arrowStartPointF.x, this.arrowStartPointF.y);\r\n    c.lineTo(this.arrowCenterPointF.x, this.arrowCenterPointF.y);\r\n    c.moveTo(this.arrowCenterPointF.x, this.arrowCenterPointF.y);\r\n    c.lineTo(this.arrowEndPointF.x, this.arrowEndPointF.y);\r\n    c.stroke();\r\n    c.closePath();在连续画多种图片/线条的时候，不要连续多次调用draw(true)方法， 消耗性能，一般最后调用fill()/stoke()方法即可。比如//绘制点\r\n        c.beginPath();\r\n        let y = node.noteView.pointFrameCenter.y + Constant.FRAME_HEIGHT / 2 + Constant.GAP_BETWEEN_DOT + Constant.RADIUS_DOT;\r\n\r\n        c.setFillStyle(Constant.LINE_COLOR_RED);\r\n        c.setLineWidth(Constant.LINE_WIDTH);\r\n        c.arc(node.noteView.pointFrameCenter.x, y, Constant.RADIUS_DOT, 0, 2 * Math.PI);\r\n\r\n        //\r\n        y += (Constant.GAP_BETWEEN_DOT + Constant.RADIUS_DOT);\r\n        c.arc(node.noteView.pointFrameCenter.x, y, Constant.RADIUS_DOT, 0, 2 * Math.PI);\r\n        //\r\n        //\r\n        y += (Constant.GAP_BETWEEN_DOT + Constant.RADIUS_DOT);\r\n        c.arc(node.noteView.pointFrameCenter.x, y, Constant.RADIUS_DOT, 0, 2 * Math.PI);\r\n\r\n        c.fill();\r\n        c.closePath();对于draw方法，建议只是调用draw()就好，不要调用draw(true)方法，draw(true)是在原画布之上再去画，不会清空旧画布，draw()会清空。一般，我们会在所有的image，rectangle，line,circle去fill/stoke完之后，再调用draw()方法，这样子就可以避免draw(true)多次，性能耗损。而且再次去reDraw的时候也不用先去清空画布。Canvas的跟随手势拖动//index.wxml\r\n  <canvas disable-scroll='true' style=\"width: {{width}}px; height: {{height}}px;background-color:#efeff4;\" canvas-id=\"canvas\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\" bindtouchend=\"touchEnd\"></canvas>\r\n//index.wcss\r\nPage {\r\n  overflow: hidden;\r\n  display: flex;\r\n}\r\n//index.js\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    width: 0,\r\n    height: 0,\r\n  },\r\n  onLoad: function (e) {\r\n    this.time = (new Date()).valueOf();\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.moveX = 0;\r\n    this.moveY = 0;\r\n\r\n    const that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        that.setData({ width: res.screenWidth, height: res.screenHeight })\r\n      },\r\n    })\r\n    const ctx = wx.createCanvasContext(\"canvas\", this)\r\n    this.canvas = ctx;\r\n  },\r\n  onReady: function () {\r\n    this.draw();\r\n  },\r\n  draw: function () {\r\n    this.canvas.fillRect(10, 10, 150, 100)\r\n    this.canvas.fill();\r\n    this.canvas.draw()\r\n  },\r\n  touchMove: function (e) {\r\n    console.log(\"touchMove\")\r\n    let xOffset = e.touches[0].x - this.x;\r\n    let yOffset = e.touches[0].y - this.y;\r\n    this.x = e.touches[0].x;\r\n    this.y = e.touches[0].y;\r\n    this.moveX = this.moveX + xOffset;\r\n    this.moveY = this.moveY + yOffset;\r\n    this.canvas.translate(this.moveX, this.moveY);\r\n    this.draw();\r\n  },\r\n  touchStart: function (e) {\r\n    this.x = e.touches[0].x;\r\n    this.y = e.touches[0].y;\r\n  },\r\n  touchEnd: function (e) {\r\n    console.log(\"touchEnd\")\r\n  }\r\n})其他的scale等方法类似。"}
{"title": "微信小程序开发--『狗蛋TV』 ", "author": "Rolan", "pub_time": "2018-5-17 00:08", "content": "狗蛋TV是基于微信小程序开发的一款App。gordanLee每天都会推荐一首歌、一篇文章、一段短视频，每天用十分钟的细碎时光，点燃内心的光明。目前分为音乐，短视频，影评三个模块。线上开源地址 https://github.com/lishuaixingNewBee/gordanTv 点个赞吧！小程序开发文档以下所有 API 均由产品公司自身提供，本人皆从网络获取。获取与共享之行为或有侵犯产品权益的嫌疑。若被告知需停止共享与使用，本人会及时删除此页面与整个项目。请您暸解相关情况，并遵守产品协议。为了方便大家学习和测试，我们提供了https的接口供大家使用，且用且珍惜。请在微信开发设置中加入request合法域名,或者在开发设置中勾选——不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书。感谢与支持-   狗蛋TVapi: https://api.gordantv.top\r\n    -   豆瓣api: https://api.douban.com\r\n    -   QQ音乐api: https://y.qq.com项目介绍狗蛋TV是基于微信小程序+ES6进行开发，能同时运行在Android、iOS环境下。涵盖了音乐、短视频、影评三个版块。开屏引导图调用微信wx.onAccelerometerChange重力感应设备API,实现水波荡漾。调用wx.getUserInfo获取用户头像。工具类用Promise封装wx.request(),简化代码结构:const $get = (url, data) => {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url,\r\n      data,\r\n      header: { 'Content-Type': 'json' },\r\n      success: resolve,\r\n      fail: reject\r\n    })\r\n  })\r\n}电影评分实现const convertToStarsArray = (average) => {\r\n  const LENGTH = 5;\r\n  const CLS_ON = 'on'; // 全星\r\n  const CLS_HALF = 'half'; // 半星\r\n  const CLS_OFF = 'off'; // 无星\r\n  let result = [];\r\n  let score = Math.round(average) / 2;\r\n  let hasDecimal = score % 1 !== 0\r\n  let integer = Math.floor(score)\r\n  for (let i = 0; i < integer; i++) {\r\n    result.push(CLS_ON)\r\n  }\r\n  if (hasDecimal) {\r\n    result.push(CLS_HALF)\r\n  }\r\n  while (result.length < LENGTH) {\r\n    result.push(CLS_OFF)\r\n  }\r\n  return result;\r\n}小程序内部组件实现上拉刷新，下拉加载方法一：scroll-view 组件\r\n    方法二：onPullDownRefresh和onReachBottom方法实现小程序下拉加载和上拉刷新阅读模块微信小程序使用wxParse解析html项目中遇到在微信小程序里需要显示音乐文章的内容，文章内容是通过接口读取的服\r\n务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，\r\n那我们需要显示html内容的时候，就可以通过wxParse来实现。项目安装\r\n    git clone git@github.com:lishuaixingNewBee/gordanTv.git\r\n目录结构\r\n\r\n|--- utils & Public Function              通用函数\r\n|--- components & components Public View  components和template模板\r\n|--- images & Img Resources               图片资源\r\n|--- pages & View Dir                     页面"}
{"title": "第一个mpvue小程序开发完了，来总结下吧 ", "author": "Rolan", "pub_time": "2018-8-7 00:23", "content": "历经了接近两个月的摸索滚爬，抓头吃瓜，各种优化（单押X3），我主导开发的第一个小程序终于要上线了（SKR SKR！）！当然首先要感谢老板没有杀了我——因为在6月初我刚拿到小程序PRD的时候老板问我多久可以做好，我看了看之后说“两周”吧，咳咳，然后。。。一直到现在，我还能活着很Amazing有没有？？？当然这其中也有一些为了追求“精品小程序”而一改再改所用的时间。好了，废话还是不多说了，下面就开始总结下吧～框架的选择    原生的小程序我本人并没有学习过，更别提拿来开发一款商用的小程序了，刚好还在前公司时，当时的前端团队在提到小程序的解决方案时有分享了mpvue，到了新公司之后技术老大也有提到mpvue，而我本人过去一年多也一直在写vue，对vue写法比较熟悉，而且新公司团队对小程序期待已久，希望尽快上架，所以选择mpvue来开发也是最快最合理的了！项目的搭建    看了mpvue的官方文档，项目的搭建自然也选择了官方推荐的 vue-cli ， 在看了五分钟上手教程后，使用命令vue init mpvue/mpvue-quickstart my-project 生成了基本的项目，在后来的开发中，项目的配置基本没做改动，只是添加了less-loader。目录结构基本上是vue-cli生成的目录结构，加了部分文件夹，主要是与后台进行数据交互所使用的框架flyio的配置文件夹（api文件夹），以及整个项目数据管理所使用的vuex（store文件夹）,整体目录结构如下：project \r\n└───build \r\n└───config \r\n└───dist \r\n└───node_modules \r\n└───src \r\n    └───api\r\n        |    ajax.js // flyio请求与响应拦截器的配置文件\r\n        |    config.js // 请求的配置文件\r\n        |    index.js // 生成请求api实例文件\r\n        |    Server.js // 项目的数据请求统一管理文件\r\n    └───components\r\n    └───pages\r\n    └───store\r\n        └───modules // vuex模块文件夹\r\n        |    index.js // vuex处理文件\r\n    |   App.vue\r\n    |   config.js\r\n    |   main.js\r\n└───static    \r\n    └───images\r\n    └───lib\r\n    └───weui\r\n│   README.md\r\n│   package.json  \r\n│   package-lock.json  \r\n复制代码踩到的坑    相信很多使用过mpvue的同学都或多或少猜到了一些坑，我也是踩到了不少的坑浪费了不少的宝贵时间，虽然网上关于mpvue的踩坑的文章一搜一箩筐，但我还是要写一下。。。下面就是我在本次小程序开发过程中遇到的坑（们）以及针对它们的解决方案：### tabBar图标问题 \r\n复制代码    在 配置小程序原生的底部tabBar 时，遇到了第一个问题：在将设计师给我的图标icon路径设置正确的情况下， 开发者工具上的tabBar的图标总是会很大，而且几乎占满了整个高度 ，相当难看，搜了很多博客都没有找到解决办法，期间还尝试了自己实现tabBar，但是在看到那令人呕呕呕的效果之后，我还是放弃了，又回到原生的tabBar，然后静下心来想了想，最后在对比github上的一些mpvue的项目之后，发现原来是图标icon的问题，最后成功解决： 就是icon尺寸保持不变，然后四周留出合适的透明（？）空白 ...很简单有木有？就这浪费我很多脑细胞，原谅我的愚钝（智障脸）。。。当然了，原生的tabBar其实还有一个问题就是， tabBar的标题文字在真机上会离底部特别特别近 ，这个我没找到解决办法，除了自己实现tabBar。。。### 详情页数据保留之前旧数据的问题\r\n复制代码    这个问题我想很多同学都遇到过了，而且我看到mpvue github上的issues里面有很多人都遇到了这个问题并且都在持续关注，足以说明这是个痛点问题，谁让它会影响小程序的用户体验呢。。。到目前为止看到的比较统一的解决办法就是：在（详情）页面onLoad的时候，将要在本页面展示的数据初始化并且进行新的赋值，举:chestnut:如下：<template>\r\n    <html-text :text=\"htmltext\"></html-text>\r\n</template>\r\n<script>\r\n    import htmlText from xxxxx\r\n    export default {\r\n        components: {\r\n            htmlText\r\n        },\r\n        data () {\r\n            return {\r\n                htmltext: ''\r\n            }\r\n        },\r\n        onLoad () {\r\n            this.htmltext = ''\r\n            this.$http.get('xxxxxxxx').then((res) => {\r\n                this.htmltext = res.htmltext\r\n            })\r\n        }\r\n    }\r\n</script>\r\n复制代码    其他数组或者对象类型的处理可能会麻烦一些，但是方法类似，在数据请求返回之前的这段时间内不想留空白尬对用户的话就自己做一些loading，总是要强过用户先面对旧数据再一闪跳到新数据的体验。。。### created钩子函数在项目初始化时就全部执行的问题  \r\n复制代码    这个我想应该是mpvue的一个bug吧？该钩子函数在页面内还是不要随便用的好。。。### 目前mpvue对于复杂富文本的支持目前性能较差的问题  \r\n复制代码    这个微信原生的路由跳转navigateTo(),redirectTo(),navigateBack(),switchTab()，reLaunch()等, 不能甩锅给mpvue，对于展示“相当复杂”的富文本（内容较长，且由多张图片甚至多张动图）的需求，一般不会有很多用户会遇到，但是很不巧的是，我遇到了。。。谁让我们致力于做一个有逼格的品牌呢？有需求了就要解决，光能展示远远不够，还得展示的优雅，目前的 mpvue-wxParse 其实已经能解决大部分问题了，也有一些github上的项目基于该项目开发得到了数百star，但是我用该项目做出来的效果老板和技术老大都相当不满意，图片没法优雅的加载，而且由于htmltext太长在图片全部解析显示出来之前有着相当长的白屏尴尬时间，所以最后还是放弃该方案。    然后在github上找到了另一个在 mpvue-wxParse 的基础上改进的针对复杂富文本的项目mpvue-htmlParse ，试了下稍微好了点，但离老板的要求还是差很远，最后不得已在此项目基础上fork出一份代码针对老板的需求亲自来改，最终得以过关，项目地址 mpvue-htmlParse ,该项目里主要针对 图片的加载 做了改进，在第一张图片加载完成后，通知主页可以关闭preLoading效果，然后给每张图片添加了菊花的加载效果，在图片完全加载完成之前会显示菊花图，然后再根据设备屏幕宽度和图片信息对图片进行适当放大或者缩小，这样整体下来的效果基本可以达到“破产版”微信公众号推文的效果，该项目适用范围有限，有需要的同学可以自己在此基础上改进。### 微信原生的路由跳转navigateTo(),redirectTo(),navigateBack(),switchTab()，reLaunch()等，在真机上的表现较为怪异\r\n复制代码    对于参数的传递，我也遇到过类似于旧数据的问题，最后不得已借助于vuex才得以解决。另外小程序的页面栈个数实在有限，所以在开发时一定要注意页面栈的管理。### onShow()的使用要注意\r\n复制代码    要记得该钩子函数里的js代码不只是刚进入页面时会执行，在息屏后再次点亮后也将会执行。对于mpvue的坑突然能想起来的不多了，目前就先写这么多，后面想起来了再来更新吧。Flyio的使用    在小程序的开发中，并没有使用小程序原生的wx.request()来进行数据交互，而是选择了mpvue文档里推荐使用的Flyio，Flyio的介绍就不多做介绍，打架可以自己看文档，这里我主要说一下的 请求和响应拦截器的构造 ：    文档里其实有很详细的介绍以及代码，但是我根据代码写下来之后在遇到登录失效的问题时并没有按照预想的解决：先锁住请求然后重新请求拿到新的cookie之后再重新进行之前的请求，再和其他人讨论之后使用promise解决了这一问题，具体可见代码：src/api/ajax.js:/**\r\n * http请求拦截器\r\n */\r\nconst Fly = require('flyio/dist/npm/wx')\r\nconst config = require('./config')\r\n\r\nconst ajaxUrl =\r\n  process.env.NODE_ENV === 'development'\r\n    ? config.Host.development\r\n    : process.env.NODE_ENV === 'production'\r\n      ? config.Host.production\r\n      : config.Host.test\r\n      \r\nlet fly = new Fly()\r\nlet loginFly = new Fly()\r\n// 定义公共headers\r\nconst headers = {\r\n  ...\r\n}\r\nObject.assign(fly.config, {\r\n  headers: headers,\r\n  baseURL: 'xxxxxx',\r\n  timeout: 10000,\r\n  withCredentials: true\r\n})\r\nloginFly.config = fly.config\r\n// session失效后本地重新登录\r\nconst login = () => {\r\n  return new Promise((resolve, reject) => {\r\n    wx.login({\r\n      success: res => {\r\n        let loginParams = {\r\n          ...\r\n        }\r\n        loginFly.post('/api/locallogin/url', loginParams).then(d => {\r\n          if (d.headers && typeof d.headers['set-cookie'] !== 'undefined') {\r\n            // 更新session\r\n            wx.setStorageSync('sessionid', d.headers['set-cookie'])\r\n          }\r\n          resolve()\r\n        }).catch(error => {\r\n          log(error)\r\n          reject(res.data)\r\n        })\r\n      },\r\n      fail: res => {\r\n        console.error(res.errMsg)\r\n      },\r\n      complete: res => {}\r\n    })\r\n  })\r\n}\r\n// 请求拦截器\r\nfly.interceptors.request.use(request => {\r\n  if (wx.getStorageSync('sessionid')) {\r\n    request.headers.cookie = wx.getStorageSync('sessionid')\r\n  }\r\n  return request\r\n})\r\n// 响应拦截器\r\nfly.interceptors.response.use(\r\n  response => {\r\n    // session已经失效，需要重新登录小程序\r\n    if (response.data.errCode === 100009) {\r\n      // log('session失效，根据之前存储在本地的用户信息重新请求session...')\r\n      // 锁定响应拦截器\r\n      fly.lock()\r\n      return login().then(() => {\r\n        fly.unlock()\r\n        // log(`重新请求：path:${response.request.url}，baseURL:${response.request.baseURL}`)\r\n        return fly.request(response.request)\r\n      }).catch(err => {\r\n        log(err)\r\n      })\r\n    } else {\r\n      return response.data.data\r\n    }\r\n  },\r\n  err => {\r\n    log('error-interceptor', err)\r\n    if (err.status) {\r\n      wx.showToast({\r\n        title: '出现未知错误',\r\n        icon: 'none',\r\n        duration: 3000\r\n      })\r\n    }\r\n  }\r\n)\r\nexport default fly\r\n复制代码vuex的使用    因为是生活购物类小程序，涉及到 购物车 + 地址选择 等较为复杂的逻辑，很多地方都需要数据共用，在本期项目中vuex起了很大的作用，因为模块较多，如果将所有数据写在一个文件里无疑会为后期维护带来巨大困难，所以将各模块的数据单独划分写在各自的文件里，这样整体流程就清晰了很多，下面是划分模块的主文件的代码src/store/index.js:import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\n\r\nimport modules1 from './modules/modules1'\r\nimport modules2 from './modules/modules2'\r\nimport modules3 from './modules/modules3'\r\n...\r\n\r\nVue.use(Vuex)\r\n\r\nexport default new Vuex.Store({\r\n  // 做模块化处理,每个功能一个store.js文件,然后统一在这边引入\r\n  modules: {\r\n    modules1,\r\n    modules2,\r\n    modules3,\r\n    ...\r\n  }\r\n})\r\n复制代码src/store/modules/modules1.js:import api from '@/api' // actions里请求用到\r\nconst state = {\r\n    aaaa,\r\n    ...\r\n}\r\nconst getters = {\r\n    aaaa (state) {\r\n        return state.aaaa\r\n    },\r\n    bbbb (state, getters, rootState) {\r\n        return getters.aaaa\r\n    },\r\n    ...\r\n}\r\n// actions里可进行异步操作\r\nconst actions = {\r\n    async anExample ({state, getters, dispatch, commit}, {params}) {\r\n        let res = await api.requestFunction({params})\r\n        ...\r\n        return res\r\n    },\r\n    ...\r\n}\r\nconst mutations = {\r\n    setStateX (state, Y) {\r\n        state.X = Y\r\n    },\r\n    ...\r\n}\r\nexport default {\r\n  namespaced: true, // 很重要\r\n  state,\r\n  getters,\r\n  actions,\r\n  mutations\r\n}\r\n复制代码在.vue文件中调用src/pages/xxx.vue<script>\r\nimport { mapState, mapGetters } from 'vuex'\r\nexport default {\r\n   computed: {\r\n        // 调用getters\r\n        ...mapGetters('modules', [\r\n            'aaaa',\r\n            'bbbb'\r\n        ]) \r\n    },\r\n    methods: {\r\n        // 调用action\r\n        funcA () {\r\n            this.$store.dispatch('modules1/anExample', {params}).then(res => {\r\n                ...\r\n            })\r\n        },\r\n        // 调用mutation\r\n        funcB () {\r\n            this.$store.commit('modules1/setStateX', Y)\r\n        }\r\n    }\r\n}\r\n</script>\r\n复制代码总结    本次总结目前先写这么多吧，主要介绍了 项目结构 ， 遇到的坑 （项目中遇到的问题很多，但是写的时候突然觉得那些都不是问题了？） ，Flyio的使用 （重点为拦截器的配置），以及 vuex的简单介绍 。其实项目开发完成之后想了想也没那么多东西，只是期间走了不少的弯路，做了很多“无用功”，其实说是无用功，但也从中收获了相当多，毕竟自己从无到有从0到1构建一个项目，其中的烦恼很多，但是真的能让人成长很多，也让我觉得相当充实。由于小程序是公司商用的不是我个人的项目，所以项目代码就没法开源了，如果有问题的话可以联系我，为防广告之嫌这里也不说明小程序的名字了，想来体验下的可以私信我，也欢迎大家来指正！    老板来找我过第二期的需求了，Incoming！"}
{"title": "微信小程序：漫画小程序项目总结 ", "author": "Rolan", "pub_time": "2018-7-30 00:15", "content": "项目考察点：1、wx:for 循环的使用。 2、this.setData 内获取动态数组数据的方式。 3、难点：在有旁白内容时，点击旁白隐藏内容，点击图片不处理事件（通过自定义 data-tag 区分，用e.currentTarget.dataset 选取子节点）。 4、e.currentTarget.dataset、e.target.dataset 用法，console.log(e) 调试技巧。 5、难点：数组数据下标为动态数据时的取值方法。项目要求：1、构建 WXML 模板。 2、使用 wx:for 循环输出四个图片，每个图片包含一个 view 组件。每个 view 中又包含一个 image 组件展示图片和一个 text 组件展示漫画旁白。 3、循环结构通过 template 形成独立模板文件。 4、为 view 组件绑定事件（其它组件不做事件绑定），默认不展示旁白，当点击图片时可以查看旁白；而在有旁白内容时，点击旁白隐藏内容，点击图片不处理事件。 5、旁白内容在 WXML 里展示，需要使用 WXS 处理，把所有半角逗号 , 改为全角逗号 ，，WXS 以独立的文件存在。wx:for 循环的使用index.js：Page({  data: {    images: [{      src: '/images/dov-1.png',      text: '',      aside: false,      unique: '0'    }, {      src: '/images/dov-2.png',      text: '过年浪一浪,爆竹好,棒棒',      aside: false,      unique: '1'    }, {      src: '/images/dov-3.png',      text: '突然一个想不开,原地爆炸好心塞',      aside: false,      unique: '2'    }, {      src: '/images/dov-4.png',      text: '吓死白熊宝宝,变成熊猫大佬',      aside: false,      unique: '3'    }]  },//......})index.wxml： <import src=\"template.wxml\"/> <view class=\"container\"> <template is=\"imgItem\" data=\"{{images}}\" /> </view>由于循环结构通过 template 形成独立模板文件，因此 wxml 文件只需引入模板。{{images}} 为 js 文件data中的 images。imgItem 对应模板文件中的 name 属性。模板template：<block wx:for=\"{{images}}\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"unique\"></block>wx:for-item 指定当前项变量名，wx:for-index 指定数组下标变量。如果不指定 wx:for-item 和 wx:for-index，数组当前项的变量名默认为 item，默认数组的当前项的下标变量名默认为 index。（文档戳这：小程序列表渲染）因此项目中 images[index] 可以用 item 代替。template.wmxl：<wxs src=\"index.wxs\" module=\"tools\" /><template name=\"imgItem\"> <view wx:for=\"{{images}}\" wx:key=\"unique\" bind:tap=\"toggleText\" data-value=\"{{item.aside}}\" data-unique=\"{{item.unique}}\"> <image src=\"{{item.src}}\" data-tag=\"image\" /> <text class=\"{{item.aside?'textShow':'textHide'}}\" data-tag=\"text\">{{tools.commaReplace(item.text)}}</text> </view></template>项目要求通过 wxs 处理半角变全角逗号问题，引入 wxs 用法是，其中 tools 是 wxs 的名称，通过 module 定义。在{{tools.commaReplace(item.text)}}中，.commaReplace 由 wxs 定义，() 中传入 js 数据。半角变全角逗号wxs：在小程序中， 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。index.wxs：function commaReplace(some_msg){  while (some_msg.indexOf(\",\") != -1) {//寻找每一个英文逗号，并替换     some_msg = some_msg.replace(\",\", \"，\");  }   return some_msg;}module.exports = {   commaReplace: commaReplace };使用 while 循环遍历字符串中每个字符的是否与半角逗号 , 匹配，如匹配使用 replace(\",\", \"，\") 方法替换，module.exports 输出模板数据供 wxml 调用。旁白的显示与隐藏index.js： toggleText: function (e){   console.log(e);   var tag = e.target.dataset.tag;   var index = e.currentTarget.dataset.unique;   var value = (!e.currentTarget.dataset.value);   var aside = 'images[' + index + '].aside';//设置images数组动态变量aside   console.log(value);   if (tag === 'image'){     if (!this.data.images[index].aside){       value = true;       this.setData({         [aside]: value       })     }   } else if (tag === 'text'){       value = false; this.setData({         [aside]: value       })   } }在小程序里，想要更新页面的数据，必须使用 this.setData 对数据进行更新。在知道数组下标或属性字段名称的情况下，可以这样写： this.setData({ 'images[0].aside': this.data.images[@].aside})数组数据下标为动态数据时的取值方法：项目中我采用的方式是给 aside 赋值，然后在 this.setData 中输出 [aside] 的方式。 var aside = 'images[' + index + '].aside';//设置images数组动态变量aside还有另一种更高级的写法，使用 JSON. stringify 把要设置的数据进行序列化，或者使用字符串拼接的方法拼出 json ，然后再重新JSON.parse 传给 setData： let json ='{\"images[' + index +'].aside\":'+ this .data .images[index] .aside.toString() +'}';this.setData(JSON.parse(json));console.log(e) 调试技巧：立正小歪牙e.target 触发事件的组件的一些属性值集合，e.currentTarget 则是当前组件的一些属性值集合。在不知道什么情况使用 e.currentTarget.dataset 还是 e.target.dataset 时，可以通过控制台打印 console.log(e) ，然后分别查看 .target 和 .currentTarget 来找到想要的属性值。触发 toggleText 时的 console.log(e) 打印信息."}
{"title": "H5与小程序如何共用的一套代码？ ——小程序混合开发 ", "author": "bmob小小琪", "pub_time": "2018-5-31 16:19", "content": "目标\r\n\r\n很多时候，大家是不是有这种想法，开发的小程序，H5与小程序能否共用的一套代码，带后端并且可以提交给微信审核？\r\n\r\n告诉你，可以！\r\n\r\n如何做呢？看下边\r\n\r\n \r\n\r\n准备工作\r\n\r\n平台：\r\n\r\n进入www.bmob.cn\r\n\r\n找到Bmob最新推出的混合平台 JSSDK库，它支持 Node.js 、微信小程序\r\n、Weex 、React Native 、Quick App 和浏览器等，写一份js可以以上任意平台。\r\n\r\n \r\n\r\n混合数据SDK\r\n\r\n文档地址： http://doc.bmob.cn/data/wechat_app_new/index.html\r\n\r\n后端直接使用Bmob后端云，如果使用自己的服务器，请求网络这块可以用Fly，同样是跨平台，具体可以上github查看。\r\n\r\n \r\n\r\n框架的选择：\r\n\r\n由于mpvue官方有跨平台前端示例，这里为了少踩点坑，选择mpvue\r\n\r\n \r\n\r\n \r\n\r\n实战\r\n\r\n1：分析页面请求\r\n\r\n需要实现的页面如下：\r\n\r\n\r\n\r\n从上图，我们可以看到这个页面，有2个数据来自后端，分表是广告图与列表数据。\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n2.建立数据表\r\n\r\n2.1广告图\r\n\r\n数据结构如下\r\n\r\n ```\r\n\r\n[\r\n\r\n  {\r\n\r\n \r\n\"title\": \"1299元起，诺基亚X6正式发布\",\r\n\r\n \r\n\"image\":\r\n\"http://img.ithome.com/newsuploadfiles/focus/f3583ca6-9a52-461b-b2b2-0f649fab0516.jpg\",\r\n\r\n \r\n\"link\": \"/pages/news/detail?id=360077&title=1299元起，诺基亚X6正式发布\"\r\n\r\n  }\r\n\r\n ]\r\n\r\n ```\r\n\r\n在后台建个表slides，导入数据/src/db/slides.json\r\n\r\n\r\n\r\n \r\n\r\n \r\n\r\n列表数据\r\n\r\n我在后台建个表newslist，导入数据/src/db/newslist.json，跟上一步一样的操作\r\n\r\n \r\n\r\n详细数据\r\n\r\n建立新闻内容表newscontent，导入数据/src/db/newscontent.json\r\n\r\n \r\n\r\n3.修改请求代码到数据库\r\n\r\n列表修改请求代码:```\r\n\r\n//api.js,getNewsList改为\r\n\r\n \r\n\r\ngetNewsList: (r) => {\r\n\r\n   \r\n//返回一个异步对象\r\n\r\n   \r\nreturn new Promise((resolve, reject) => {\r\n\r\n   \r\n//查询`newslist` 数据\r\n\r\n     \r\nconst query = Bmob.Query('newslist')\r\n\r\n     \r\nquery.find().then(res => {\r\n\r\n        \r\n//返回一个json数据\r\n\r\n       \r\nresolve({'newslist': res})\r\n\r\n     \r\n}).catch(err => {\r\n\r\n       \r\nreject(err)\r\n\r\n     \r\n})\r\n\r\n   \r\n})\r\n\r\n  },\r\n\r\n ```\r\n\r\n数据已经从Bmob数据库调用出来了。广告图操作一样，具体代码看github（https://github.com/bmob/ithome-lite）\r\n\r\n \r\n\r\n这样就实现了，首页的广告、数据列表、内容展示功能，如果您的小程序只是一个展示功能，可以使用此代码进行修改。"}
{"title": "小程序的拖拽、缩放和旋转手势 ", "author": "Rolan", "pub_time": "2018-6-8 00:23", "content": "在开发中，有时会遇到像App中的手势那样的效果，下面就仿照App实现了一下。wxml部分：<view class=\"touch-container\">\r\n <view class=\"msg\">{{msg}}</view>\r\n <image\r\n class=\"img\"\r\n src=\"{{src}}\"\r\n style=\"width: {{width}}rpx; height: {{height}}rpx; left: {{left}}rpx; top: {{top}}rpx; transform: translate(-50%, -50%) scale({{ scale }}) rotate({{ rotate }}deg);\"\r\n bindload=\"bindload\"\r\n catchtouchstart=\"touchstart\"\r\n catchtouchmove=\"touchmove\"\r\n catchtouchend=\"touchend\"\r\n ></image>\r\n</view>\r\nwxss部分：page {\r\n  width: 100%;\r\n  height: 100%;\r\n  background: #ffffff;\r\n}\r\n.touch-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  padding-top: 0.1px;\r\n}\r\n.msg {\r\n  width: 100%;\r\n  height: 60rpx;\r\n  line-height: 60rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  color: #666666;\r\n}\r\n.img {\r\n  position: absolute;\r\n  width: 690rpx;\r\n  height: 300rpx;\r\n  transform-origin: center center;\r\n}\r\njs部分：var canOnePointMove = false\r\nvar onePoint = {\r\n  x: 0,\r\n  y: 0\r\n}\r\nvar twoPoint = {\r\n  x1: 0,\r\n  y1: 0,\r\n  x2: 0,\r\n  y2: 0\r\n}\r\nPage({\r\n  data: {\r\n    msg: '',\r\n    src: 'http://img01.taopic.com/150508/318763-15050PU9398.jpg',\r\n    width: 0,\r\n    height: 0,\r\n    left: 375,\r\n    top: 600,\r\n    scale: 1,\r\n    rotate: 0\r\n },\r\n // 关闭上拉加载\r\n  onReachBottom: function() {\r\n return\r\n },\r\n  bindload: function(e) {\r\n var that = this\r\n var width = e.detail.width\r\n var height = e.detail.height\r\n if (width > 750) {\r\n      height = 750 * height / width\r\n      width = 750\r\n }\r\n if (height > 1200) {\r\n      width = 1200 * width / height\r\n      height = 1200\r\n }\r\n    that.setData({\r\n      width: width,\r\n      height: height\r\n })\r\n },\r\n  touchstart: function(e) {\r\n var that = this\r\n if (e.touches.length < 2) {\r\n      canOnePointMove = true\r\n      onePoint.x = e.touches[0].pageX * 2\r\n      onePoint.y = e.touches[0].pageY * 2\r\n }else {\r\n      twoPoint.x1 = e.touches[0].pageX * 2\r\n      twoPoint.y1 = e.touches[0].pageY * 2\r\n      twoPoint.x2 = e.touches[1].pageX * 2\r\n      twoPoint.y2 = e.touches[1].pageY * 2\r\n }\r\n },\r\n  touchmove: function(e){\r\n var that = this\r\n if (e.touches.length < 2 && canOnePointMove) {\r\n var onePointDiffX = e.touches[0].pageX * 2 - onePoint.x\r\n var onePointDiffY = e.touches[0].pageY * 2 - onePoint.y\r\n      that.setData({\r\n        msg: '单点移动',\r\n        left: that.data.left + onePointDiffX,\r\n        top: that.data.top + onePointDiffY\r\n })\r\n      onePoint.x = e.touches[0].pageX * 2\r\n      onePoint.y = e.touches[0].pageY * 2\r\n }else if (e.touches.length > 1) {\r\n var preTwoPoint = JSON.parse(JSON.stringify(twoPoint))\r\n      twoPoint.x1 = e.touches[0].pageX * 2\r\n      twoPoint.y1 = e.touches[0].pageY * 2\r\n      twoPoint.x2 = e.touches[1].pageX * 2\r\n      twoPoint.y2 = e.touches[1].pageY * 2\r\n // 计算角度，旋转(优先)\r\n var perAngle = Math.atan((preTwoPoint.y1 - preTwoPoint.y2)/(preTwoPoint.x1 - preTwoPoint.x2))*180/Math.PI\r\n var curAngle = Math.atan((twoPoint.y1 - twoPoint.y2)/(twoPoint.x1 - twoPoint.x2))*180/Math.PI\r\n if (Math.abs(perAngle - curAngle) > 1) {\r\n        that.setData({\r\n          msg: '旋转',\r\n          rotate: that.data.rotate + (curAngle - perAngle)\r\n })\r\n }else {\r\n // 计算距离，缩放\r\n var preDistance = Math.sqrt(Math.pow((preTwoPoint.x1 - preTwoPoint.x2), 2) + Math.pow((preTwoPoint.y1 - preTwoPoint.y2), 2))\r\n var curDistance = Math.sqrt(Math.pow((twoPoint.x1 - twoPoint.x2), 2) + Math.pow((twoPoint.y1 - twoPoint.y2), 2))\r\n        that.setData({\r\n          msg: '缩放',\r\n          scale: that.data.scale + (curDistance - preDistance) * 0.005\r\n })\r\n }\r\n }\r\n },\r\n  touchend: function(e) {\r\n var that = this\r\n    canOnePointMove = false\r\n }\r\n})\r\njson部分：\"navigationBarTitleText\": \"识别手势\",\r\n \"navigationBarTextStyle\":\"black\",\r\n \"navigationBarBackgroundColor\": \"#FFF\",\r\n \"disableScroll\": true\r\n如有问题，请大家多多指教！作者：honey缘木鱼 链接：https://www.jianshu.com/p/ec95cd4a6941 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "找工作怎么办，拉勾小程序来帮你 ", "author": "Rolan", "pub_time": "2018-6-14 00:27", "content": "现在的前端有各种各样的新知识和新框架，小程序才出生几年，就已经火到这种程度了，所以作为前端学习者，这个新技能我们是一定要尽快get到的。学习小程序最好的方法就是自己手写一个小程序，能从中找到自己的不足之处。于是我便萌发了一个新想法，自己手撸一个拉勾小程序。刚开始的时候，起步是有点难的，不知道怎么把学的东西转化成自己想要写的东西，但谢了一点后，感觉有点入迷了，停不下来。希望我写的东西能够帮助社区的学习者，如果写的不好，也欢迎你指正。开发工具与资源平台微信web开发者工具：用于敲网页代码，但是最主要用来进行手机效果预览。VsCode:主要用于布局排版，也是敲代码的主战场，真心觉得这个编辑器不错，快捷输入和排版，大大提高了开发效率，使用简单，一学就会。Iconfont-阿里巴巴矢量图标库 ：提供项目中的所有图标，资源丰富。微信小程序开发者文档:微信小程序开发的文档，资源库，以及API规范Easy Mock: 可以模拟我们想要的数据，非常方便。这里是部分数据预览图片功能展示数据请求拉勾里面有非常多的数据，所以我在easy mock里面创建了很多接口，在页面需要用到的时候去\r\n请求数据，如果每一次都要用wx.request，而且到处都是异步请求，处理时会遇到很多的麻烦，\r\nes6中的promise可以将异步变成同步(vue中的async和await也可以)，封装一个request在以后\r\n的开发中也用得到的封装的requestfunction request(params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: params.url,\r\n      method: params.method || 'get',\r\n      data: params.data,\r\n      header: {\r\n        'content-type': 'application/json'\r\n      },\r\n      success: resolve,\r\n      error: err => {\r\n        console.log(\"请求出错:\" + err.errMsg);\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\n\r\nexport default request》import request from '../../utils/request.js'\r\n需要请求数据引入request.js查看页面详情查看页面详情就是讲你点击的那个id传过去，但是我在这里遇到了一个坑，我在寻找点击的那个id的详情时，发现我匹配不了我的数据，后来我一步一步打印找事哪一步有问题，发现我用easymock造的数据，传的id是个字符串而不是数字，所以我将传过来id转化成数字在去进行匹配，得到了想要点击的详情页。getActive(id) {\r\n    const url = 'https://www.easy-mock.com/mock/5b06da4872643c7a5c4edcd1/api/desc#!method=get';\r\n    var params = {\r\n      url: url,\r\n      method: 'GET',\r\n    };\r\n    let position = [];\r\n    let currentDesc = this.data.currentDesc;\r\n    request(params).then(res => { //异步变同步\r\n      position = res.data.data.position;\r\n    }).then(() => {\r\n      for (let i = 0; i < position.length; i++) {\r\n        if (i === id) {\r\n          let that = this;\r\n          that.setData({\r\n            currentDesc: position[i]\r\n          })\r\n          console.log(that.data.currentDesc)\r\n        }\r\n      }\r\n    }\r\n      );\r\n  },\r\n  onLoad: function (options) {\r\n    let id = options.id - 0; //将id转化成number\r\n    this.getActive(id); //请求数据匹配id\r\n  },搜索因为是用markdown造的假数据，数据不是很多，而且这不是像有后端的那样，可以传给后端参数，让后端给你提供符合的数据，所以还是得要自己干。刚开始实现时，第一时间想到的是用indexOf()去判断，如果不含有我输入的字符串，就返回-1，通过这点去判断。写这个只要知道大概的想法，一般是不怎么会出错的。onInput(e) {\r\n    let value = e.detail.value;\r\n    // console.log(value);\r\n    const job = this.data.job;//匹配的数组\r\n    var list = [];\r\n    for(var i = 0; i < job.length; i++){\r\n      if(job[i].indexOf(value)>-1){//不包含value就返回-1\r\n        list.push(job[i]);\r\n      }\r\n    }\r\n    this.setData({\r\n      list: list,\r\n      ['search.content']: value\r\n    });\r\n  },我这一部分之前是有小bug的，页面从后一个页面回来时，搜索的记录会变成历史记录，同时搜索的值还会在input上，但是同样列表还显示在下面，这样就会造成用户体验及不良好，所以我给整个的搜索匹配到的列表一个三元运算符，点击跳转之前就会将其设为false，然后列表就会隐藏起来，从后一个页面返回时也不会出现那种状况。<view class=\"item-lists {{isShoeLists?'hidden':''}}\">\r\n            <view class=\"weui-cell border-botton\" wx:for=\"{{list}}\" wx:key=\"index\" bindtap=\"positionSearch\" data-index=\"{{index}}\">\r\n                <view class=\"weui-cell__hd \">\r\n                    <image src=\"../../images/job-search-pic.png\" style=\"margin-right: 5px;vertical-align: middle;width:30px; height: 30px;\"></image>\r\n                </view>\r\n                <view class=\"weui-cell__bd job-desc\">{{item}}</view>\r\n                <view class=\"weui-cell__ft\"></view>\r\n            </view>\r\n        </view>positionSearch(e) {\r\n    // console.log(e)\r\n    let list = this.data.list\r\n    let index = e.currentTarget.dataset.index;\r\n    let value = list[index];\r\n    let history = this.data.history;\r\n    history.push(value); //将搜索的记录放入到历史搜索中\r\n    this.setData({\r\n      ['search.content']: value,\r\n      history,\r\n      isShowLists: true // 将lists隐藏\r\n    })\r\n    wx.navigateTo({\r\n      url: `../related/related?value=${value}`,\r\n    })\r\n  },scroll-view会碰到的问题请勿在scroll-view之中使用 textarea、map、canvas、videoscroll-into-view的优先级高于scroll-viewscroll-view需要给scroll-view一个固定的宽度或高度，设置属性scroll-x或scroll-y,并且设置样式white-space:nowrap;（这个很重要，不设置这个样式，无法完成scroll-view的效果如果要下拉刷新时，请使用scroll-view组件自带的方法，在scroll-view中滚动是不会触发onPullDownRefresh事件的页面返回传值跳转页面的时候，可以通过navigateTo将要传递参数放在url上，但是返回原页面时，就得换过一种传参方法。一种是在app.js中设置golbaldata，然后在你想要传值的地方去设置golbaldata就可以了，或者你将数据储存在stroage里面。还有一种就是 getCurrentPages() ，getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。不要尝试修改页面栈，会导致路由以及页面状态错误。changecity(e) {\r\n    var value = e.target.dataset.value;\r\n    var pages = getCurrentPages();\r\n    var currPage = pages[pages.length - 1];  //当前页面\r\n    var prevPage = pages[pages.length - 2]; //上一个页面\r\n    prePage.setData({\r\n      location: value,\r\n      city: value\r\n    });\r\n    wx.navigateBack({\r\n      delta: 1\r\n    })\r\n  },编辑简历用weui去写微信小程序去写节省我们一部分的时间。这个功能这里也有一个需要将值传回来的，我在这里是将参数传入stroage里面，因为我想换一种方式去实现。在个人信息中，有一个表单验证，在这里，我除了一个大亏。先贴代码，看看我写的表单验。<view class=\"container\">\r\n \r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__hd\">\r\n                    <view class=\"weui-label\">真实姓名</view>\r\n                </view>\r\n                <view class=\"weui-cell__bd\">\r\n                    <input class=\"weui-input name-input\" type=\"text\" value=\"{{val}}\" bindinput=\"nameChange\" placeholder=\"请输入\" />\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__bd\">性别</view>\r\n                <view class=\"weui-cell__ft\">\r\n                    <picker bindchange=\"bindSexChange\" value=\"{{index}}\" range=\"{{arraySex.sex}}\" class=\"name-input\">\r\n                        <view class=\"selectPick\" wx:if=\"{{!arraySex.isPickSelect}}\">\r\n                            <text>请选择</text>\r\n                        </view>\r\n                        <view wx:else class=\"picker\">\r\n                            {{arraySex.sex[arraySex.index]}}\r\n                        </view>\r\n                    </picker>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__bd\">出生日期</view>\r\n                <view class=\"weui-cell__ft\">\r\n                    <picker mode=\"date\" value=\"{{date}}\" start=\"1949-10-01\" end=\"2018-06-01\" bindchange=\"bindDateChange\">\r\n                        <view class=\"picker\">\r\n                            {{date}}\r\n                        </view>\r\n                    </picker>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__bd\">最高学历</view>\r\n                <view class=\"weui-cell__ft\">\r\n                    <picker bindchange=\"bindEducationChange\" value=\"{{index}}\" range=\"{{arrayEducation.education}}\">\r\n                        <view class=\"selectPick\" wx:if=\"{{!arrayEducation.isPickSelect}}\">\r\n                            <text>请选择</text>\r\n                        </view>\r\n                        <view wx:else class=\"picker\">\r\n                            {{arrayEducation.education[arrayEducation.index]}}\r\n                        </view>\r\n                    </picker>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__bd\">工作经验</view>\r\n                <view class=\"weui-cell__ft\">\r\n                    <picker bindchange=\"bindExperienceChange\" value=\"{{index}}\" range=\"{{arrayExperience.experience}}\">\r\n                        <view class=\"selectPick\" wx:if=\"{{!arrayExperience.isPickSelect}}\">\r\n                            <text>请选择</text>\r\n                        </view>\r\n                        <view wx:else class=\"picker\">\r\n                            {{arrayExperience.experience[arrayExperience.index]}}\r\n                        </view>\r\n                    </picker>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__hd\">\r\n                    <view class=\"weui-label\">手机号码</view>\r\n                </view>\r\n                <view class=\"weui-cell__bd\">\r\n                    <input class=\"weui-input name-input\" type=\"number\" value=\"{{val}}\" bindinput=\"telChange\" placeholder=\"请输入\" />\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__hd\">\r\n                    <view class=\"weui-label\">联系邮箱</view>\r\n                </view>\r\n                <view class=\"weui-cell__bd\">\r\n                    <input class=\"weui-input name-input\" type=\"email\" value=\"{{val}}\" bindinput=\"mailChange\" placeholder=\"请输入\" />\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"weui-cells weui-cells_after-title name\">\r\n            <view class=\"weui-cell weui-cell_input\">\r\n                <view class=\"weui-cell__bd\">所在城市</view>\r\n\r\n                <view class=\"weui-cell__ft\" bindtap=\"cityChange\">\r\n                    <view wx:if=\"{{!isChooseCity}}\" class=\"changeCity\">\r\n                        <text>请选择</text>\r\n                    </view>\r\n                    <view wx:else class=\"changeCity\">{{city}}</view>\r\n                </view>\r\n\r\n            </view>\r\n        </view>\r\n        <view class=\"bgft\">\r\n            <view class=\"introduction\">\r\n                <view class=\"intro\">\r\n                    <text>一句话介绍自己</text>\r\n                    <view class=\"wordNum\">{{num}}/60</view>\r\n                </view>\r\n                <view>\r\n                   \r\n                    <textarea placeholder=\"说出你的心声\" value=\"{{value}}\" maxlength=\"60\" class=\"input\" bindinput=\"inputChange\" />\r\n                </view>\r\n            </view>\r\n            <button class=\"btnEdit\"  bindtap=\"formSubmit\">保存</button>\r\n        </view>\r\n</view>formSubmit(e) {\r\n    \r\n\r\n    //验证是否输入名字\r\n    let nameVal = this.data.nameVal;\r\n    if (!this.errorInput(nameVal, '请输入你的名字')) {\r\n      return false;\r\n    };\r\nconsole.log(nameVal)\r\n    //验证是否选择性别\r\n    let sex = this.data.arraySex.sex[this.data.arraySex.index];\r\n    if (!this.error(this.data.arraySex.isPickSelect, '请选择你的性别')) {\r\n      return false;\r\n    };\r\nconsole.log(sex)\r\n    //验证是否选择了出生日期\r\n    let date = this.data.date;\r\n    if (date === '1999-01-01') {\r\n      w"}
{"title": "小程序的十万个为什么丨框架 ", "author": "Rolan", "pub_time": "2018-6-21 14:55", "content": "Q：小程序如何设置页面路径？\r\n\r\n\r\n\r\n \r\n\r\nQ：小程序如何设置默认页面窗口表现？\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n\r\n \r\n\r\nQ：小程序如何设置底部tab表现？\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n\r\nQ：小程序如何设置网络超时时间? \r\n\r\n\r\n\r\n \r\n\r\nQ：小程序如何进行数据绑定？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/data.html\r\n\r\n \r\n\r\nQ：小程序如何列表渲染？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html\r\n\r\n \r\n\r\nQ：小程序如何条件渲染\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html\r\n\r\n \r\n\r\nQ：小程序如何定义、使用模板？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/template.html\r\n\r\n \r\n\r\nQ：小程序事件使用详解？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html\r\n\r\n \r\n\r\nQ：小程序如何引用？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/import.html\r\n\r\n \r\n\r\nQ：小程序中如何注释？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/03annotation.html\r\n\r\n \r\n\r\nQ：小程序模块\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/01wxs-module.html\r\n\r\n \r\n\r\nQ：小程序变量\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/02variate.html\r\n\r\n \r\n\r\nQ：小程序运算符如何使用？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/04operator.html\r\n\r\n \r\n\r\nQ：小程序if、switch、for、whlie语句使用方法？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/05statement.html\r\n\r\n \r\n\r\nQ：小程序样式导入？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html\r\n\r\n \r\n\r\nQ：小程序如何创建、使用自定义组件？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/\r\n\r\n \r\n\r\nQ：小程序如何开发插件？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html\r\n\r\n \r\n\r\nQ：小程序如何使用组件？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/plugin/using.html\r\n\r\n \r\n\r\nQ：小程序如何使用分包加载？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html\r\n\r\n \r\n\r\nQ：小程序兼容方式？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html\r\n\r\n \r\n\r\nQ：小程序运行机制？\r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html"}
{"title": "原型故事之「蜂巢群聊」小程序 ", "author": "Rolan", "pub_time": "2018-6-29 00:01", "content": "这是开篇的第一个原型故事，与你分享~专题故事背景最近在做产品设计的过程中发现了一个现象，在一个产品原型投入到开发之前，会有无数个想法成为陪跑者。这些想法有的因为资源不够而搁置，有的因为商业节奏不对调整了优先级，也有的因为过于异想天开而一笑了之，更有的因为在讨论会中被怒怼到直接流产。但是不可否认的是，每一个点子和原型都是对新世界的一种假设，夹着无数的可能性。这些可能性既然在自己手里无法实现，那就拿到市场上去摆摊儿上赏识者免费领走！这也就是这个专题的初心。这些点子未来会成为什么样子？这些原型未来会成为什么样子？谁也不知道！但是谁也不能否认，它具有改变世界的可能性！原型故事-蜂巢群聊1. 对骂群的诞生哲学这是开篇的第一个原型故事，起源于前一段时间爆火的对骂群。我也是一个对骂群的运营者。群因我而起，我传播群二维码的渠道只有朋友圈和我几个混的比较熟和一点也不熟悉的群聊。有意思的点就在这里出现了，开启骂战的时候，我发现基本全是我的同事再和我的前同事或者我的前前同事对骂，作为他们的一级人脉我是无法出口的，为了继续保持我端庄的形象只能端庄的坐着冷静的观察。不过这一瞬间的火爆，是微信这个庞大帝国刻意隐藏的冲突，这个冲突背后蕴藏的无尽的力量，虽然抵不过微信的一道圣旨。这个力量源于-熟人社交。微信月活10亿，日活9亿，抢夺了用户大量的时间精力，不少用户也因此被彻底捆绑而放弃其他陌生人社交的产品。这样，积攒已久的问题就出现了，每天可交流的永远是固定几类群体，同事，朋友，同学及家人。我看个NBA比赛也只能在体育频道自嗨，随口在弹幕里喷两句，虽然满屏参与者，但是对于你一个单独个体来说，依然孤独。想找一群一起和我讨论詹姆斯下赛季去向的问题都没有，但是 实际上与你有相同个性和爱好需求的群体散布在这个世界上，你无法通过极简的方式去触碰 。当突然间有一个对骂群正好是自己感兴趣的话题，又有对这个话题做了充分准备的一大波群体，按耐已经的情绪终于要得到释放，自己又要重新做起了这个领域的意见领袖，不燃才怪！！因为对骂本身就是一种目的性极强的社交行为，所以在对骂群诞生拜把子兄弟，甚至找到终身伴侣都不稀奇。2. 蜂巢群聊-性格社交的诞生基于以上的分析，我的原型设计想解决的问题就变的非常容易理解。“打破熟人社交，让更多具有相同兴趣爱好的群体可以直接对话”。我用一种群聊共享的方式去实现我的想法。简单描述就是，所有人都可以在平台上上传群聊并添加群聊介绍，提交后，需要平台进行审核，通过后会展示在相应的分类当中。用户根据自己的需求去申请添加相应的群。问题来了，什么场景下才会有这样的需求呢？如果只像我上述对骂群那样的场景倒是没有什么社会价值！当然不仅如此！场景=时间+地点+以下内容：想找到一起支持巴西队的粉丝群体，想找到一起支持王菊的粉丝群体想找到京东优惠卷的分发的群，可以得到专属渠道优惠想找到附近的户外爱好者一起出去穿越想找到高中学生家长群，可以分享优质的学习资源想找到英语爱好者的用户群想找到区块链课程分享群想找到PM招聘群，直接微信找人想找到小程序“跳一跳”的玩家群，一起玩接力·······有人说了，你这个跟微博还有好多设计类APP有功能上的重合啊！还是那句话， 基于10亿用户的社交软件内做小程序，将用户和应用之间的耗能降低到极致，极简的社交方式是微信群聊的核心优势。3. 初版原型（1）蜂巢群聊小程序-首页热门的群聊分类+今日热点话题的“阅后即焚”的玩法，阅后即焚的玩法延续了对骂群的特质，但是每一个话题都新增倒计时，让讨论者在有限的时间集中讨论，并毫无顾虑，时间一到，群聊自动解散。（2）我的用户每进一个群都需要消耗一个鸡腿（虚拟货币），增加进群门槛并以此控制同一个人加群的数量并通过做人任务的形式去实现用户增长。（3）加群先阅读群资料，再决定是否入群，做到兴趣匹配。当然，加入群聊是个双向匹配的过程，群主也需要审核申请者的资料。（4）分类明细逐渐提供更加细分的品类可供选择。4. 简版分析（1）解决的问题① 对于需求方：信息不对称，用户无法快速找到微信群并辨别其质量，例：我作为一个家长想找一个高考资料共享群去哪里找？难精准找到共同兴趣话题讨论的社群② 对于供给方虽然基于10亿用户的微信建立用户群，但是很难脱离自己的二级人脉直接寻找毫无关联的用户得以直接营销，例：新上一个小程序，去哪找首批粉丝群体？（2）用户群体① 商家/企业及对商家提供的服务有需求的用户：以拉新为目的例：区块链媒体、教育类APP、新上的小程序、等所有企业② 兴趣话题爱好者：具有共同兴趣爱好的的小团体例：音乐、户外、交友、粉丝、招聘（3）市场规模微信日活用户：9.02亿微信月活用户：10.4亿微信小程序上线：58万微信小程序日活：1.7亿（4）谁给赋能小程序本身，基于10亿用户的轻量级应用市场。（5）场景见上文（6）切入点保证群聊高质量的前提下，也要提高用户群体的质量，为了易于早期传播选择当前最火的几个主题进行切入：区块链、小程序、优质热门话题，之后再逐渐丰富。① 区块链区块链的火热带动诞生了无数个企业，媒体、交易所、项目方等等等，所以大V粉丝社群、交易所企业社群、项目方社群有极大的流量需求等等，那么对于大多韭菜来说，信息的不对称也让每一个韭菜对进入优质信息群及其渴望② 小程序游戏群其实这是我感觉最有价值也是可能爆发的版块，对于微信平台来说，在微信APP中是没有小程序商城的，也不允许小程序商城类的小程序上架，所以小程序玩家群入手则是更好的选择，不仅可以体验小程序，还可以在社群中把小程序的社群属性发挥到极致，如果提高认知仔细思考，这个版块是小程序商店的升级版③ 优质话题群实时热点的高质量讨论组，近期的对骂群的诞生已经反映出用户对陌生人间无压力沟通的渴望和快感，“世界杯彩票包养群”“菊外人粉丝群”“崔永元事件实时跟进群”等等，热点每天都有，给用户提供一个发泄的地方（7）小程序矩阵群空间群活动群投票找校友群通知好友位置等等其实衍生出来的设计还有好多，等我一一把原型故事写出来！希望各位杠精在评论区进行提问，跟老司机讨论可行性！万一实现了呢！！作者：郎诗文（公众号：Geek未来实验室），葡萄学院产品经理，曾混迹于趣店、银客等金融领域，现负责在线教育公司的前后端产品设计。本文由 @郎诗文 原创发布于人人都是产品经理。未经许可，禁止转载。题图由作者提供"}
{"title": "React转微信小程序：从React类定义到Component调用 ", "author": "Rolan", "pub_time": "2018-7-4 00:10", "content": "这是本系列的第二篇，过去两周，已经有相当成果出来。本文介绍其中一部分可靠的思路，这个比京东的taro更具可靠性。如果觉得看不过瘾，可以看anu的源码，里面包含了miniapp的转换器。微信小程序是面向配置对象编程，不暴露Page,App,Component等核心对象的原型，只提供三个工厂方法，因此无法实现继承。App,Page,Component所在的JS的依赖处理也很弱智，你需要声明在同一目录下的json文件中。比如说Component({\r\n  properties: {},\r\n  data: {},\r\n  onClick: function(){}\r\n})\r\nproperties与data都是同一个东西，properties只是用来定义data中的数据的默认值与类型，相当于React的defaultProps与propTypes。如何转换呢？import {Component} form \"./wechat\"\r\nClass AAA extends Component{\r\n  constructor(props){\r\n     super(props);\r\n     this.state = {}\r\n  }\r\n  static propTypes = {}\r\n  static defaultProps = {}\r\n  onClick(){}\r\n  render(){}\r\n}\r\nexport AAA;\r\n首先我们要提供一个wechat.js文件，里面提供Component, Page, App 这几个基类，现在只是空实现，但已经足够了，保证它在调试不会出错。我们要的是`Class AAA extends Component`这个语句的内容。学了babel，对JS语法更加熟悉了。这个语句在babel6中称为ClassExpression，到babel7中又叫ClassDeclaration。babel有一个叫\"babel-traverse\"的包，可以将我们的代码的AST，然后根据语法的成分进行转换（详见这文章 https://yq.aliyun.com/articles/62671）。ClassDeclaration的参数为一个叫path的对象，我们通过 path.node.superClass.name 就能拿到Component这个字样。如果我们的类定义是下面的这样，path.node.superClass.name 则为App。Class AAA extends App{\r\n  constructor(props){\r\n     super(props);\r\n     this.state = {}\r\n  }\r\n}\r\nApp, Page, Component对应的json差异很大，拿到这个可以方便我们区别对待。然后我们继续定义一个ImportDeclaration处理器，将import语句去掉。定义ExportDefaultDeclaration与ExportNamedDeclaration处理器，将export语句去掉。到这里我不得不展示一下我的转码器的全貌了。我是通过rollup得到所有模块的路径与文件内容，然后通过babel进行转译。babel转换是通过babel.transform。babel本来就有许多叫babel-plugin-transform-xxx的插件，它是专门处理那些es5无法识别的新语法。我们需要在这后面加上一个新插件叫miniappPlugin// https://github.com/RubyLouvre/anu/blob/master/packages/render/miniapp/translator/transform.js\r\n\r\nconst syntaxClassProperties = require(\"babel-plugin-syntax-class-properties\")\r\nconst babel = require('babel-core')\r\nconst visitor = require(\"./visitor\");\r\n\r\nvar result = babel.transform(code, {\r\n        babelrc: false,\r\n        plugins: [\r\n            'syntax-jsx',\r\n            //  \"transform-react-jsx\",\r\n            'transform-decorators-legacy',\r\n            'transform-object-rest-spread',\r\n            miniappPlugin,\r\n        ]\r\n})\r\nfunction miniappPlugin(api) {\r\n    return {\r\n        inherits: syntaxClassProperties,\r\n        visitor: visitor\r\n    };\r\n}\r\nminiappPlugin的结构异常简单，它继承一个叫syntaxClassProperties的插件，这插件原来用来解析es6 class的属性的，因为我们的目标也是抽取React类中的defaultProps, propsTypes静态属性。visitor的结构很简单，就是各种JS语法的描述。const t = require(\"babel-types\");\r\n\r\nmodule.exports = {\r\n   ClassDeclaration: 抽取父类的名字与转换构造器,\r\n   ClassExpression: 抽取父类的名字与转换构造器,\r\n   ImportDeclaration(path) {\r\n     path.remove() //移除import语句，小程序会自动在外面包一层，变成AMD模块\r\n   },\r\n   ExportDefaultDeclaration(path){\r\n     path.remove() //AMD不认识export语句，要删掉，或转换成module.exports\r\n   },\r\n   ExportNamedDeclaration(path){\r\n     path.remove() //AMD不认识export语句，要删掉，或转换成module.exports\r\n   }\r\n}\r\n我再介绍一下visitor的处理器是怎么用的，处理器其实会执行两次。我们的AST树每个节点会被执行两次，如果学过DFS的同学会明白，第一次访问后，做些处理，然后进行它内部的节点，处理后再访问一次。于是visitor也可以这样定义。ClassDeclaration:{\r\n   enter(path){},\r\n   exit(path){}\r\n}\r\n如果以函数形式定义，那么它只是作为enter来用。AST会从上到下执行，我们先拿到类名的名字与父类的名字，我们定义一个modules的对象，保存信息。enter(path) {\r\n let className = path.node.superClass ? path.node.superClass.name : \"\";\r\n let match = className.match(/\\.?(App|Page|Component)/);\r\n if (match) {\r\n //获取类的组件类型与名字\r\n      var componentType = match[1];\r\n      if (componentType === \"Component\") {\r\n        modules.componentName = path.node.id.name;\r\n      }\r\n      modules.componentType = componentType;\r\n   }\r\n},\r\n我们在第二次访问这个类定义时，要将类定义转换为函数调用。即Class AAA extends Component   ---> Component({})\r\n实现如下，将原来的类删掉（因此才在exit时执行），然后新建一个函数调用语句。我们可以通过babel-types这个句实现。具体看这里。比如说：const call = t.expressionStatement(\r\n     t.callExpression(t.identifier(\"Component\"), [ t.objectExpression([])])\r\n);\r\npath.replaceWith(call);\r\n就能产生如下代码，将我们的类定义从原位置替换掉。Component({})\r\n但我们不能是一个空对象啊，因此我们需要收集它的方法。我们需要在visitors对象添加一个ClassMethod处理器，收集原来类的方法。类的方法与对象的方法不一样，对象的方法叫成员表达式，需要转换一下。我们首先弄一个数组，用来放东西。var methods = []\r\nmodule.exports= {\r\n  ClassMethod: {\r\n    enter(path){\r\n       var methodName = path.node.key.name\r\n       var method = t.ObjectProperty(\r\n            t.identifier(methodName),\r\n            t.functionExpression(\r\n                null,\r\n                path.node.params,\r\n                path.node.body,\r\n                path.node.generator,\r\n                path.node.async\r\n            )\r\n        );\r\n       methods.push(method)\r\n   }\r\n} \r\n然后我们在ClassDeclaration或ClassExpression的处理器的exit方法中改成：const call = t.expressionStatement(\r\n     t.callExpression(t.identifier(\"Component\"), [ t.objectExpression(methods)])\r\n);\r\npath.replaceWith(call);\r\n于是函数定义就变成Component({\r\n   constructor:function(){},\r\n   render:function(){},\r\n   onClick: function(){}\r\n})\r\n到这里，我们开始另一个问题了。小程序虽然是抄React，但又想别出心裁，于是一些属性与方法是不一样的。比如说data对应state, setData对应setState，早期的版本还有forceUpdate之类的。data对应一个对象，你可以有千奇百怪的写法。this.state ={  a: 1}\r\nthis[\"state\"] = {b: 1};\r\nthis.state = {}\r\nthis.state.aa = 1\r\n你想hold住这么多奇怪的写法是很困难的，因此我们可以对constructor方法做些处理，然后其他方法做些约束，来减少转换的成本。什么处理constructor呢，我们可以定义一个onInit方法，专门劫持constructor方法，将this.state变成this.data。function onInit(config){\r\n    if(config.hasOwnProperty(\"constructor\")){\r\n       config.constructor.call(config);\r\n    }\r\n    config.data = config.state|| {};\r\n    delete config.state\r\n    return config;\r\n}\r\nComponent(onInit({\r\n   constructor:function(){},\r\n   render:function(){},\r\n   onClick: function(){}\r\n}))\r\n具体实现参这里，本文就不贴上来了。RubyLouvre/anu那this.setState怎么转换成this.setData呢。这是一个函数调用，语法上称之为**CallExpression**。我们在visitors上定义同名的处理器。 CallExpression(path) {\r\n    var callee = path.node.callee || Object;\r\n    if ( modules.componentType === \"Component\" ) {\r\n       var property = callee.property;\r\n      if (property && property.name === \"setState\") {\r\n          property.name = \"setData\";\r\n      }\r\n    }\r\n  },\r\n至少，将React类定义转换成Component({})调用方式 成功了。剩下就是将import语句处理一下，因为要小程序中，如果这个组件引用了其他组件，需要在其json中添加useComponens对象，将这些组件名及链接写上去。换言之，小程序太懒了，处处都要手动。有了React转码器，这些事可以省掉。其次是render方法的转换，怎么变成一个wxml文件呢，`{}单花括号的内容要转换成`\"{{}}\"`双引号＋双花括号 ，wx:if, wx:for的模拟等等，且听下回分解。"}
{"title": "我与小程序的故事以及小程序框架选型 ", "author": "Rolan", "pub_time": "2018-7-12 00:31", "content": "我的一些关于小程序的看法和社区框架选型比较，部分观点取之于社区。Vue重度使用者也许会在wepy和mpvue中徘徊，React和TypeScript重度使用者在现阶段当之无愧Taro首选。      这是一篇我与小程序的故事，但小程序的过去却与我无关。      曾经与她错失交臂，但愿一切还来得及。      毕业后的两年内，一直在创业公司工作，但自己却错过了很多创业风口，如区块链和小程序，唯独跟风了机器学习，但这是一条漫长的路，需要潜心学术否则很难做出成绩，我曾在现公司AI Labs的某部门工作过一段时间，深知这一点。      区块链和小程序在如今看来，无疑在过去的一年里都是程序员创业的风口，甚至可以说是风向标。      我之前待过的一家创业公司，主要做股票行业投顾平台的业务，React Native承载了所有面向用户的APP产品需求，整个前后端技术团队最多的时候也只有11人，虽然是一家很小的创业公司，但两位创始人中，CEO曾是奇虎360 Web产品及商业产品业务线副总经理，联合创始人是某大型券商高管，因此公司对产品的技术也曾多次摸索，数字货币涉及区块链，智能投顾涉及机器学习，量化投资涉及程序化交易，机会很多，但说实话要做好这些方向实在是太难，尤其16年国内股票市场一直处于熊市的低谷中徘徊。因思想，而光华；因变革，而机遇；因蜕变，而不凡。      在16年小程序内测的时候就听说过小程序，但真正接触小程序是17年1月10日，某券商给我当时在的创业公司两个名额，我有幸受邀参加了在北京大学光华管理学院举办的”小程序，大变革-2017年小程序全国巡回沙龙“，小程序的正式发布仅仅是在一天之前的1月9日。      小程序的诞生，就一路伴随着赞赏和争议不断，从发布上线时候不被大多数人看好，我便是其中之一，到如今的逐渐火热，甚至可以说是如日中天，在移动互联网创业领域一骑绝尘，17年后半年到如今的创业黑马。小程序刚出来的时候，我可能和大多数人的想法一样，中大型的互联网公司不可能去拥抱腾讯生态圈，受限于腾讯爸爸苛刻的游戏规则。      然而在这一年里，小程序用时间与实践证明了自己的变革与价值，微信小程序的规则也在开发社区的影响下变得更加完善。      对于第三方企业来讲，微信为自己带来了巨大的流量入口和低成本的拉新渠道，如滴滴、美团、京东等公司都推出了自己的小程序。像共享单车类的企业，微信是绝大多数用户的二维码扫码入口，小程序为其带来了巨大的流量入口，如摩拜单车、青桔单车、街兔电单车小程序。      对于小程序开发者来说，小程序的开发生态不断地在完善，从最开始的原生框架，到类vue规范的wepy，再到近vue写法的mpvue，再到最近刚推出的遵循React规范的Taro。这期间，也曾有过类React的小程序框架Labrador，但小程序正式发布没多久就几乎停止维护了。      真正让我感到惊喜的是Taro这个小程序框架，虽然推出的时间最短，但脚手架中自带TypeScript编译选项，这无疑是企业级小程序应用的首选框架，no，我认为，哪怕只是一个单人维护的小型应用，TypeScript也是必备的，可以让开发者避免一些低级错误的bug，以及让代码的可维护性更高。      Taro 是凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架，是React系开发者的福音。      Taro官方称“只要书写一套代码，通过Taro编译工具将源代码分别编译出可以在不同端（微信小程序、H5、APP端[React Native]）运行的代码，同时Taro还提供了开箱即用的语法检测和自动补全等功能，有效地提升了开发体验和开发效率”。Taro所具备的优势：NPM包管理系统ES6+语法自由的资源引用CSS预处理器和后处理器（SCSS、Less、PostCSS）灵活的JSX写法TypeScript      在我看来，wepy和mpvue都想尽可能地提供一套类vue的写法，但小程序的运行环境始终和Web端存在着差异，不可能完美地支持vue的所有指令及过滤器等等。开发者不但要去踩小程序自身的坑，还要去记住wepy和mpvue到底有哪些vue的特性不能使用，这着实是叫人头大啊。      React和原生的小程序开发方式比更加现代化、规范化、组件化，JSX比Vue的字符串模板也具有更强的表现力。JSXrender () {  return (          {this.state.list.map((item, idx) => (        {item}      ))}      this.func}>方法      )}复制代码小程序模板<view class=\"index\">  <view wx:key={idx} wx:for=\"{{list}}\" wx:for-item=\"item\" wx:for-index=\"idx\">{{item}}view>  <view bindtap=\"func\">方法view>view>复制代码      JSX 其实本质上就是 JS，我们可以在里面写任意的逻辑代码，这样一来就比字符串模板的表现力与操作性要强多了，况且，小程序的字符串模板功能比较羸弱，只有一些比较基本的功能。      Taro有着和React完全一致的API和组件化系统。在 Taro 中，不用像原生小程序一样区分什么是 App 组件，什么是 Page 组件，什么是 Component 组件，Taro 全都是 Component 组件，并且和 React 的生命周期几乎完全一致。      Taro 和 React 一样，同样使用声明式的 JSX 语法。相比起字符串的模板语法，JSX 在处理精细复杂需求的时候会更得心应手，示例代码如下：Taro的其他几项优点：具备良好的开发效率和体验：编辑器对Taro的支持和React几乎是一样的。类型安全和运行时检测：可以使用TypeScript或Flow来对代码的可靠性进一步增强。高效的自动补全和 ES6+ 语法：Taro 的所有 API（包括微信小程序等端能力接口）都有智能的提醒和自动补全，包括接口的参数和返回值。技术选型与权衡      小程序社区已经有多个优秀的框架以小程序为核心对多端适配进行了探索，我们将各个开发框架的主要特点和特性进行了对比并制成图表。大家可以结合团队技术栈、技术需求以及框架特点、特性进行选型和权衡。在后续文章中，会带大家一起用Taro框架来实战开发小程序。"}
{"title": "微信小程序车牌键盘 ", "author": "Rolan", "pub_time": "2018-7-24 00:21", "content": "项目背景公司要做一个停车场微信小程序，支持临时车预支付以及支付记录查询等功能,其中涉及车牌输入的功能，为了提升用户体验，避免繁琐的输入，决定自己写一个键盘。效果图如下省份简写键盘如下:省份简写键盘英文简写键盘如下:英文简写键盘源代码目录结构目录结构wxml文件内容<view wx:if=\"{{isShow}}\" class=\"vehicle-panel\" style=\"height:430rpx;background-color:{{backgroundColor}}\">  <!--省份简写键盘-->  <block wx:if=\"{{keyBoardType === 1}}\">    <view class=\"vehicle-panel-row\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button' style=\"border:{{buttonBorder}}\" wx:for=\"{{keyVehicle1}}\" bindtap='vehicleTap' data-value=\"{{item}}\" wx:for-index=\"idx\" wx:key=\"idx\">{{item}}</view>    </view>    <view class=\"vehicle-panel-row\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button' style=\"border:{{buttonBorder}}\" wx:for=\"{{keyVehicle2}}\" bindtap='vehicleTap' data-value=\"{{item}}\" wx:for-index=\"idx\" wx:key=\"idx\">{{item}}</view>    </view>    <view class=\"vehicle-panel-row\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button' style=\"border:{{buttonBorder}}\" wx:for=\"{{keyVehicle3}}\" bindtap='vehicleTap' data-value=\"{{item}}\" wx:for-index=\"idx\" wx:key=\"idx\">{{item}}</view>    </view>    <view class=\"vehicle-panel-row-last\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button vehicle-panel-row-button-last' bindtap='vehicleTap' data-value=\"{{item}}\" wx:for=\"{{keyVehicle4}}\" style=\"border:{{buttonBorder}}\" wx:for-index=\"idx\" wx:key=\"idx\">{{item}}</view>    </view>  </block>  <!--英文键盘  -->  <block wx:else>    <view class=\"vehicle-panel-row\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button vehicle-panel-row-button-number' bindtap='vehicleTap' data-value=\"{{item}}\" wx:for=\"{{keyNumber}}\" style=\"border:{{buttonBorder}}\" wx:for-index=\"idx\" wx:key=\"item\">{{item}}</view>    </view>    <view class=\"vehicle-panel-row\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button' style=\"border:{{buttonBorder}}\" wx:for=\"{{keyEnInput1}}\" bindtap='vehicleTap' data-value=\"{{item}}\" wx:for-index=\"idx\"  wx:key=\"idx\">{{item}}</view>    </view>    <view class=\"vehicle-panel-row\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button' style=\"border:{{buttonBorder}}\" wx:for=\"{{keyEnInput2}}\" bindtap='vehicleTap' data-value=\"{{item}}\" wx:for-index=\"idx\" wx:key=\"idx\">{{item}}</view>      <view hover-class=\"vehicle-hover\" style=\"border:{{buttonBorder}}\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button vehicle-panel-row-button-img'>        <image src='./delete.svg' class='vehicle-en-button-delete' bindtap='vehicleTap' data-value=\"delete\" mode='aspectFit'>删除</image>      </view>    </view>    <view class=\"vehicle-panel-row-last\">      <view hover-class=\"vehicle-hover\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button vehicle-panel-row-button-last' bindtap='vehicleTap' style=\"border:{{buttonBorder}}\" data-value=\"{{item}}\" wx:for=\"{{keyEnInput3}}\" wx:for-index=\"idx\" wx:key=\"idx\">{{item}}</view>      <view hover-class=\"vehicle-hover\" style=\"border:{{buttonBorder}}\" hover-start-time=\"10\" hover-stay-time=\"100\" class='vehicle-panel-row-button vehicle-panel-ok' bindtap='vehicleTap' data-value=\"ok\">确定</view>    </view>  </block></view>json文件{  \"component\": true}js文件Component({   externalClasses: ['v-panel'],   properties: {    isShow: {      type: Boolean,      value: false,    },    buttonBorder: {      type: String,      value: \"1px solid #ccc\"    },    backgroundColor:{      type: String,      value: \"#fff\"    },    //1为省份键盘，其它为英文键盘    keyBoardType: {      type: Number,      value: 1,    }  },  data: {    keyVehicle1: '陕京津沪冀豫云辽',    keyVehicle2: '黑湘皖鲁新苏浙赣',    keyVehicle3: '鄂桂甘晋蒙吉闽贵',    keyVehicle4: '粤川青藏琼宁渝',    keyNumber: '1234567890',    keyEnInput1: 'QWERTYUIOP',    keyEnInput2: 'ASDFGHJKL',    keyEnInput3: 'ZXCVBNM',  },  methods: {    vehicleTap: function (event) {      let val = event.target.dataset.value;      switch (val){        case 'delete':          this.triggerEvent('delete');          this.triggerEvent('inputchange');        break;        case 'ok':          this.triggerEvent('ok');        break;        default:          this.triggerEvent('inputchange', val);      }    },  }});wxss文件:host {  width: 100%;}.vehicle-panel {  width: 100%;  position: fixed;  bottom: 0;  display:flex;  flex-direction:column;  justify-content:center;  z-index: 1000;}.vehicle-panel-row {  display: flex;  justify-content: space-between;  align-items: center;}.vehicle-panel-row-last{  display: flex;  justify-content: space-between;  align-items: center;}.vehicle-panel-row-button {  background-color: #fff;  margin: 5rpx;  padding: 5rpx;  width: 80rpx;  height: 80rpx;  text-align: center;  line-height: 80rpx;  border-radius: 10rpx;}.vehicle-panel-row-button-number {  background-color: #eee;}.vehicle-panel-row-button-last {  width: 90rpx;  height: 90rpx;  line-height: 90rpx;}.vehicle-hover {  background-color: #ccc;}.vehicle-panel-row-button-img {  display: flex;  justify-content: center;  align-items: center;}.vehicle-en-button-delete {  width: 55rpx;  height: 85rpx;}.vehicle-panel-ok {  background-color: #0F4BA1;  color: #fff;  width: 150rpx;  height: 80rpx;}使用方式示例<v-panel is-show=\"{{isShow}}\" bindok=\"inputOk\" binddelete=\"inputdelete\" bindinputchange=\"inputChange\" key-board-type=\"{{keyBoardType}}\" backgroundColor=\"white\" />\r\n属性属性名称类型默认值说明isShow布尔(boolean)false控制键盘是否显示,true显示，false不显示buttonBorder字符串(String)\"1px solid #ccc\"控制键盘按钮边框，同css border属性backgroundColor字符串(String)#fff控制键盘背景色,同csskeyBoardType数字(Number)1控制键盘显示类型,1为省份简写,2为英文简写事件事件名称触发情况返回值delete删除按钮按下的时候触发微信事件ok确定按钮按下时触发微信事件inputchange输入按钮按下或者删除按钮按下时触发输入的值完毕!以上代码仅供大家学习交流相关推荐：在微信小程序中使用“随机键盘”"}
{"title": "多人对战游戏开发实例之《组队小鸡射击》（附源码） ", "author": "Rolan", "pub_time": "2018-7-24 00:37", "content": "前言：该游戏项目主要是基于前端引擎Cocos Creator开发，涉及后端联网的部分，则通过接入Matchvs SDK完成快速开发工作。准备工作Matchvs JavaScript SDK 下载地址Matchvs JavaScript 的Cocos Creator 插件使用手册Cocos Creator 下载地址《组队小鸡射击》玩法简介：双方通过控制各自小鸡，通过不断点击屏幕进行空中飞行射击，被击中者将消耗以爱心为单位的生命值，游戏支持四人同时实时对战。点击并拖拽以移动​实现步骤游戏实现部分可拆分为三个步骤来实现：用户登录、随机匹配和创建房间及同屏游戏。用户登录​使用Cocos Creator(以下简称CC)创建游戏登录场景​ 使用CC 拖动控件, 还原设计稿 , 依托CC的良好的工作流,使得这部分的工作可以由游戏策划或者UI设计者来完成,程序开发者只需要在场景中挂载相应的游戏逻辑脚本. 举个例子,在登录按钮挂在一个uiLogin.js的脚本完成用户登录功能.uilogin.fire新建js脚本文件选中场景任一控件添加组件,选中刚新建的脚本,在脚本的onLoad函数中给按钮添加点击监听,触发登录操作uiLogin.js​onLoad() {this.nodeDict[\"start\"].on(\"click\", this.startGame, this);},startGame() {Game.GameManager.matchVsInit();}实现this.startGame函数. 登录之前需要初始化Matchvs SDK:uiLogin.jsuiLogin.jsvar uiPanel = require(\"uiPanel\");cc.Class({extends: uiPanel,\r\nproperties: {},​onLoad() {\r\n    this._super();\r\n    this.nodeDict[\"start\"].on(\"click\", this.startGame, this);\r\n},​startGame() {\r\n    Game.GameManager.matchVsInit();\r\n}});​​Game.GameManager.jsmatchVsInit: function() {mvs.response.initResponse = this.initResponse.bind(this);\r\nmvs.response.errorResponse = this.errorResponse.bind(this);\r\n// 用户登录之后的回调\r\nmvs.response.loginResponse = this.loginResponse.bind(this); ​var result = mvs.engine.init(mvs.response, GLB.channel, GLB.platform, GLB.gameId);\r\nif (result !== 0) {\r\n    console.log('初始化失败,错误码:' + result);\r\n}}初始化需要的几个参数在Matchvs官网注册即可得到,注册地址 http://www.matchvs.comchannel: 'MatchVS',\r\nplatform: 'alpha',\r\ngameId: 201330,\r\ngameVersion: 1,\r\nappKey: '7c7b185482d8444bb98bc93c7a65daaa',\r\nsecret: 'f469fb05eee9488bb32adfd85e4ca370',注册成功后,登录Matchvs游戏云,返回UserID,登录成功.gameManager.js​registerUserResponse: function(userInfo) {var deviceId = 'abcdef';\r\nvar gatewayId = 0;\r\nGLB.userInfo = userInfo;​console.log('开始登录,用户Id:' + userInfo.id)​var result = mvs.engine.login(\r\n    userInfo.id, userInfo.token,\r\n    GLB.gameId, GLB.gameVersion,\r\n    GLB.appKey, GLB.secret,\r\n    deviceId, gatewayId\r\n);\r\nif (result !== 0) {\r\n    console.log('登录失败,错误码:' + result);\r\n}},​loginResponse: function(info) {if (info.status !== 200) {\r\n    console.log('登录失败,异步回调错误码:' + info.status);\r\n} else {\r\n    console.log('登录成功');\r\n    this.lobbyShow();\r\n}},随机匹配和创建房间使用CC创建大厅场景(uiLobbyPanel.fire)给用户选择匹配方式,创建匹配场景(uiMatching1v1.fire) 给用户反馈比配进度和登录功能的实现步骤类似:写一个 uiMatching1v1.js脚本挂在到场景中的控件上.uiMatching1v1.jsjoinRandomRoom: function() {var result = mvs.engine.joinRandomRoom(GLB.MAX_PLAYER_COUNT, '');\r\nif (result !== 0) {\r\n    console.log('进入房间失败,错误码:' + result);\r\n}},通过监听joinRoomResponse和joinRoomNotify匹配结果gameManager.jsjoinRoomResponse: function(status, roomUserInfoList, roomInfo) {if (status !== 200) {\r\n    console.log(\"失败 joinRoomResponse:\" + status);\r\n    return;\r\n}\r\nvar data = {\r\n    status: status,\r\n    roomUserInfoList: roomUserInfoList,\r\n    roomInfo: roomInfo\r\n}\r\n// 把事件发给关心这个事件的节点脚本\r\nclientEvent.dispatch(clientEvent.eventType.joinRoomResponse, data);},​joinRoomNotify: function(roomUserInfo) {var data = {\r\n    roomUserInfo: roomUserInfo\r\n}\r\nclientEvent.dispatch(clientEvent.eventType.joinRoomNotify, data);},同屏游戏 , 实现游戏同步还是按照上面的套路,新建场景(uiGamePanel.fire),在playerManager.js中,加载了player.js.在player.js中,攻击的动作使用Matchvs 的 sendEventEx发出,player.jshurt: function(murderId) {var msg = {\r\n    action: GLB.PLAYER_HURT_EVENT,\r\n    playerId: this.userId,\r\n    murderId: murderId\r\n};\r\nGame.GameManager.sendEventEx(msg);}另一方的客户端收到后处理事情;gameManager.js​// 玩家行为通知--sendEventNotify: function(info) {if (info.cpProto.indexOf(GLB.PLAYER_HURT_EVENT) >= 0) {\r\n    if (Game.GameManager.gameState !== GameState.Over) {\r\n        player = Game.PlayerManager.getPlayerByUserId(cpProto.playerId);\r\n        if (player) {\r\n            player.hurtNotify(cpProto.murderId);\r\n        }\r\n        // 检查回合结束--\r\n        var loseCamp = Game.PlayerManager.getLoseCamp();\r\n        if (loseCamp != null) {\r\n            Game.GameManager.gameState = GameState.Over\r\n            if (GLB.isRoomOwner) {\r\n                this.sendRoundOverMsg(loseCamp);\r\n            }\r\n        }\r\n    }\r\n}}​开发完成后， 再通过CC的微信小游戏一键发布功能上线微信即可。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "pub_time": "2016-10-12 22:39", "content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序调起键盘性能优化 ", "author": "Rolan", "pub_time": "2018-7-25 00:06", "content": "在小程序中，我们经常有调起键盘的操作场景，但是在不同的场景下解决方案不尽相同，还是需要具体问题具体分析。需求分析最近在项目中有一个需求，是从列表页点击评论按钮进入详情页时，在加载完页面后自动调起键盘进入评论状态。从需求来看，我们应该在onReady函数中调起键盘，因为onReady函数是在页面初次渲染完成时被调用。但是在实践中我们发现，对于一些配置不好的手机，其加载页面速度较慢，在onReady函数调用时页面并没有渲染完毕，就会导致placeholder和input组件位置错乱的现象。其本质原因是，onReady生命周期函数并不能在调用时承若已经将页面渲染完成了。（尽管文档中描述是已经完成了。）之前的操作是在onReady生命周期函数中调起键盘。this.setData({ focus: true })\r\n复制代码发现这个问题后做了相应的延迟处理setTimeout(() => {\r\n  this.setData({ focus: true })\r\n}, 300)\r\n复制代码但这是治标不治本的方法，手机性能好的用户会无谓的等待300毫秒，而手机性能很差的用户等待300毫秒也不一定就能解决这个问题。解决思路那么既然小程序并没有提供给我们一个理想的渲染结束后的回调函数，那么我们就换个思路： 使用短轮询来处理，当页面渲染完成后才调起键盘的操作。既然要使用短轮询，那么我们去轮询什么呢？什么标志代表着页面渲染完成了呢？在这里，我是使用 wx.createSelectorQuery() 方法，它会返回一个SelectorQuery对象实例，在这个实例上调用select方法选择我想要去轮询的节点，在回调函数中判断参数是否为 null 。如果返回了监控的节点信息，那么说明已经渲染完成。这时就可以进行键盘调起操作了。let timer = setInterval(() => {\r\n  wx.createSelectorQuery().select('#comment-section').boundingClientRect(rect => {\r\n    if (rect !== null && timer !== null) {\r\n      clearInterval(timer)\r\n      timer = null\r\n      this.setData({ focus: true })\r\n    }\r\n  }).exec()\r\n}, 50)\r\n复制代码在此之上，如果我们只粗暴的让 focus 为 true 并不是个明智的做法。在调起键盘时默认页面会上推，如果在评论很少的情况下这样的体验并不好。所以需要判断一个高度，超过这个值就上推，没超过就不上推。这个值视实际情况而定。 上推的操作是由input组件的 adjust-position 属性决定，为true则上推，否则则不上推。这时回调返回的参数中的节点信息就可以派上用场了。// 在this.setData({ focus: true })前对节点高度进行判断\r\nif (rect.height < 500) this.setData({ push: false })\r\nelse this.setData({ push: true })\r\n复制代码onBlur函数问题在实际的操作中，我们发现在键盘被调起后会有概又自动收回。经过排查发现时onBlur函数的问题，在onBlur函数中，我们手动的设置 focus 为 false ，但其实并不需要这一步操作，反而带来了副作用。在我们去除了这部分代码后，键盘自动收起的问题得到了解决。封装起来虽然我们完成了这次任务的需求，但是显而易见的，这样的任务在未来肯定还会再次出现。所以机智的我们应该赶快把整套流程封装起来，以便下次直接调用。那么这时我们使用的方式就是这样的：const Util = require(\"xxx\") // 引入封装的库\r\n\r\n/**\r\n * 生命周期函数--监听页面初次渲染完成\r\n */\r\nonReady: function () {\r\n  Util.onTotalReady('#comment-section', 50, rect => {\r\n    if (rect.bottom < 500) this.setData({ push: false })\r\n    else this.setData({ push: true }}\r\n    this.setData({ focus: true })\r\n  })\r\n}\r\n复制代码小结在解决键盘调起的这个过程中我们可以看出微信小程序开发流程的简陋，这个问题的出现本质上是小程序提供给我们的生命周期函数的不够准确。否则在页面渲染完成的情况下我怎么会拿不到节点信息呢？像react中的componentWillMount生命周期函数中就不会出现这样的问题，所以希望小程序能再变强大一些，也让我们少写一点这种hack代码。"}
{"title": "weapp-cookie：一行代码让微信小程序支持 cookie ", "author": "Rolan", "pub_time": "2018-7-25 00:12", "content": "一行代码让微信小程序支持 cookie，传送门： githubIntro微信原生的 wx.request 网络请求接口并不支持传统的 Cookie，但有时候我们现有的后端接口确于依赖 Cookie（比如服务器用户登录态），这个库可用一行代码为你的小程序实现 Cookie 机制，以保证基于 cookie 的服务会话不会失效，与 web 端共用会话机制Installnpm install weapp-cookie --save\r\n\r\n# 将 npm 包复制到 vendor 文件夹，避免小程序可能不能找到文件（tips：使用 wepy/mpvue 等框架无需此步）\r\ncp -rf ./node_modules/ ./vendor/\r\n复制代码Usage在小程序根目录的 app.js 一行代码引入即可// app.js\r\nimport './vendor/weapp-cookie/index'\r\n\r\n// tips: 使用 wepy/mpvue 可以直接在入口 js 引入 weapp-cookie 模块\r\n// import 'weapp-cookie'\r\n\r\nApp({\r\n    onLaunch: function () { }\r\n    // ...\r\n})\r\n复制代码原来的 wx.request 调用方式保持不变，引入后 weapp-cookie 会在底层自动代理 wx.request 的接口访问，以支持 cookie 存储和发送// pages/home/index.js\r\n\r\nPage({\r\n    onLoad: function () {\r\n        wx.request({\r\n            url: 'https://example.com/login',\r\n            data: {\r\n                username: 'admin',\r\n                password: '123456'\r\n            },\r\n            success: function (res) {\r\n                /*\r\n                 * 接口调用成功后 weapp-cookie 会自动保存后端发送的所有Cookie（比如：SessionID）\r\n                 * 并在后续的所有请求中带上，以保证基于 cookie 的服务器会话机制不会失效，\r\n                 * 实现与 web 端共用会话机制（无需再手动维护 3rd_session_key） \r\n                 */\r\n            }\r\n        })\r\n    }\r\n})\r\n复制代码如果对你有用，欢迎 star ^_^"}
{"title": "小程序开发实用技巧——扩展 Page 页面对象 ", "author": "Rolan", "pub_time": "2018-7-25 00:18", "content": "小程序是通过调用 Page 函数来注册一个页面的：//index.js\r\nPage({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    }, function() {\r\n      // this is setData callback\r\n    })\r\n  }\r\n})\r\n复制代码这里 Page 的作用相当于构造函数， Page 会初始化页面对象（实例），然后将配置参数中的属性 merge 到页面对象上。假设你封装了个 http 模块负责发出请求，你想在页面对象中直接通过 this.http 引用这个模块，就需要扩展页面对象。要扩展一个对象，在 JavaScript 中的常见做法是扩展构造函数的 prototype 属性，这是 Vue 很多插件的实现：import axios from 'axios'\r\nVue.prototype.axios = axios\r\n// 在 vue 组件中\r\nthis.axios.get(api).then(callback)\r\n复制代码很不幸，在小程序中这个办法无效。 Page 并不是普通的构造函数，底层还做了很多其他事情，没办法直接通过 Page.prototype 扩展页面对象。我们可以转变思路，扩展传进 Page 的配置对象。既然始终要通过调用 Page 注册页面，可以定义一个函数，这个函数会将收到的配置对象参数进行处理，然后再传给 Page 。// wxPage.js\r\nimport http from '../utils/http'\r\n\r\nconst wxPage = function(config) {\r\n  config.http = http\r\n  return Page(config)\r\n}\r\n\r\nexport default wxPage\r\n复制代码注册页面的时候改用这个 wxPage ：import Page from './wxPage'\r\n\r\nPage({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    console.log(this.http) // 打印 http 模块变量\r\n    this.http.get(api).then(callback) // 直接调用 http 的方法\r\n  },\r\n})\r\n复制代码直接修改 Page 函数为了增强页面对象，每个需要的页面都得引入 wxPage 是一件不太省心的事；更多时候我们是在维护一个老项目，需要扩展每个原有的页面对象，这时可以直接修改 Page ：const originalPage = Page //保存原来的Page\r\nPage = function(config) { // 覆盖Page变量\r\n  config.http = http\r\n  return originalPage(config)\r\n}\r\n复制代码一般来说，修改 Page 的时机是在 App onLoad 的时候。这样原有的页面不用修改，直接就能通过 this.http 拿到 http 。通过扩展 Page 页面对象实现常见需求1. 给生命周期方法增加通用逻辑有时我们希望在页面注册的 onLoad 阶段执行一些通用的逻辑，例如埋点，打 log 等，这时可以改写配置对象中的 onLoad 方法：const originalPage = Page\r\nPage = function(config) {\r\n  const { onLoad } = config\r\n  config.onLoad = function(onLoadOptions) {\r\n    // 打 log、埋点……\r\n    console.log('每个页面都会打出这个log')\r\n    if (typeof onLoad === 'function') {\r\n      onLoad.call(this, onLoadOptions)\r\n    }\r\n  }\r\n  return originalPage(config)\r\n}\r\n复制代码2. 获取上一页页面对象小程序中的页面跳转会形成一个页面栈，栈中存放着每个页面对象，可以通过getCurrentPages 方法获得这个页面栈。可以在页面 onLoad 的时候获取这个页面栈，然后取出倒数第二个对象，就是当前页上一页的页面对象：// 接上...\r\n  const { onLoad } = config\r\n  config.onLoad = function(onLoadOptions) {\r\n    const pages = getCurrentPages()\r\n    this.__previousPage = pages[pages.length - 2] // 将上一页的页面对象赋为this.__previousPage\r\n    if (typeof onLoad === 'function') {\r\n      onLoad.call(this, onLoadOptions)\r\n    }\r\n  }\r\n  return originalPage(config)\r\n复制代码这样在页面对象中可通过引用 this.__previousPage 获取上一页页面对象的data及所有方法，这样在一些只需要两个页面互动的情景下，当前页直接调用上一个页面对象的方法（相当于回调）后再返回，比通过全局状态管理上一页的数据要方便。3. 跳转页面并传递数据到下一页这个不多说了，直接看代码吧：// 接上\r\nconfig.navigateTo = function(url, params) { // 实现一个navigateTo方法，参数包括跳转url和要传递的参数\r\n  this.__params = params\r\n  wx.navigateTo({ url })\r\n}\r\n\r\nconfig.onLoad = function(onLoadOptions) {\r\n  const pages = getCurrentPages()\r\n  this.__previousPage = pages[pages.length - 2] // 将上一页的页面对象赋为this.__previousPage\r\n  if (this.__previousPage) {\r\n    onLoadOptions.params = this.__previousPage.__params // 获取上一页面的__params赋给onLoad函数的options\r\n    delete this.__previousPage.__params\r\n  }\r\n  if (typeof onLoad === 'function') {\r\n    onLoad.call(this, onLoadOptions)\r\n  }\r\n}\r\n\r\n// A 页面跳转 B 页面\r\nthis.navigateTo('urlToB', { foo: 'bar' })\r\n\r\n// B 页面的 onLoad\r\nPage({\r\n  onLoad(options) {\r\n    console.log(options.params) // { foo: 'bar' }\r\n  }\r\n})\r\n复制代码就写到这里吧，在使用原生方案开发的时候，这些技巧还是挺实用的。以后再写写怎样构建小程序，使小程序支持文件预编译、require npm 包等。"}
{"title": "微信小程序适配 iPhone X 总结 ", "author": "Rolan", "pub_time": "2018-7-26 00:03", "content": "本文主要介绍我们的知识小集小程序在适配 iPhone X 屏幕时遇到的一些问题以及总结，希望对你的小程序开发能有所帮助。iPhone X 屏幕数据在去年 9 月份 iPhone X 正式发布后，引发了一波 iOS App 适配 iPhone X 的热潮和技术文章，详情可以参考掘金技术社区的这个专题： 《iPhone X 适配实践》我们这里先简单总结一下 iPhone X 屏幕的基础数据，方便后续在小程序开发中进行适配。屏幕尺寸：5.8 英寸（对角线）屏幕物理分辨率：1125px × 2436px，458 ppi实际开发适配尺寸：375pt × 812pt，@3x此外，由于在 iPhone X 屏幕顶部状态栏区域有“齐刘海”，以及在屏幕底部增加了“操作条”，如下图所示，因此，我们在开发中需要注意 安全区域 的问题。根据苹果官方的文档，iPhone X 顶部状态栏的适配安全区域的高度为 44pt，底部操作条区域的高度为 34pt。另外，在 iPhone X 中，一些系统 Bar 的默认高度相比于之前的设备也发生了变化，如下表所示。所以在 iOS App 开发中，如果我们使用系统默认的 UINavigationController 和 UITabBarController 时，则无需额外的适配工作，iOS 系统会自动适配好相关 Bar 的安全区域问题。如果我们使用了自定义的导航栏和标签栏，则需要注意根据设备类型区分设置这些 Bar 的不同高度。小程序的尺寸单位为了解决不同屏幕尺寸的适配问题，小程序自己定了一个尺寸单位：rpx（responsive pixel），它可以根据屏幕宽度进行自适应。小程序中规定， 所有设备的屏幕宽度都为 750rpx ，根据设备屏幕实际宽度的不同，1rpx 所代表的实际像素值也不一样。根据 微信开发文档 ，在 4.7 英寸的 iPhone 设备上（iPhone 6/7/8），屏幕宽度为 375px（此处应该理解为 375 point），共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1物理像素。小程序中如何判断设备为 iPhone X上面我们简要介绍了 iPhone X 的屏幕数据和小程序中的尺寸单位作为铺垫，现在终于要切入正题了，要在小程序中适配 iPhone X 屏幕，首先我们需要知道如何判断设备类型。微信的小程序 API 中提供了一个 wx.getSystemInfo(OBJECT) 方法用于获取用户手机的系统信息和设备信息，包含如下数据：上述每个字段的含义详见 文档 ，我们不再一一赘述。因此，我们可以根据该方法返回的手机型号字段 model 是否包含 iPhone X 字符串来判断设备是否为 iPhone X，也可以根据 screenHeight 的高度是否等于 812 来判断。NOTE:这里有一个小坑需要注意，在微信开发者工具中的模拟器，如果选择为 iPhone X，此时获取到的 model 值为 iPhone X ，导致我以为真机也是这个值，于是直接用 if (model == 'iPhone X') 来判断，但其实真机下 model 的值为这种格式： iPhone X (GSM+CDMA)<iPhone10,3> ，因此我们需要用字符串检索匹配进行判断。综上，我们可以在 app.js 的 globalData 中添加一个字段 isIPX 用于标识当前设备是否为 iPhone X，然后在小程序启动时 onLaunch 中调用 wx.getSystemInfo(OBJECT) 方法并在其 success回调中读取 model 字段进行分析，代码大致如下：App({\r\n  // 全局数据\r\n  globalData: {\r\n    // 其他数据定义 ...\r\n    \r\n    isIPX: false, // 当前设备是否为 iPhone X\r\n  },\r\n  \r\n  // 小程序启动入口\r\n  onLaunch: function (options) {\r\n    // 其他启动代码...\r\n    \r\n    // 判断设备是否为 iPhone X\r\n    this.checkIsIPhoneX()\r\n  },\r\n  \r\n  checkIsIPhoneX: function() {\r\n    const self = this\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // 根据 model 进行判断\r\n        if (res.model.search('iPhone X') != -1) {\r\n          self.globalData.isIPX = true\r\n        }\r\n        // 或者根据 screenHeight 进行判断\r\n        // if (res.screenHeight == 812) {\r\n        //   self.globalData.isIPX = true\r\n        // }\r\n      }\r\n    })\r\n  },\r\n}\r\n如果需要小程序启动时立即获取设备相关信息，也可以调 wx.getSystemInfoSync() 方法，它会同步获取数据并立即返回。页面适配实战在小程序页面开发中，涉及到需要适配 iPhone X 的地方主要有：导航栏（NavigationBar），标签栏（TabBar）以及页面底部的吸底按钮。导航栏和标签栏适配如果我们使用微信小程序官方组件进行开发，没有进行自定义，在 app.json 文件中设置 tabBar 页面，且 window 的 navigationStyle 值为 default ，那么我们无需在 iPhone X 中对导航栏和标签栏进行适配，微信会自动帮我们适配好，如下图为知识小集小程序的首页：但是我们如果是自定义导航栏（在 app.json 文件中设置 window 的 navigationStyle 为 custom ，此时只保留右上角胶囊状的按钮，需要开发者自己画导航栏样式）和标签栏，则我们需要在每个页面中判断设备类型，并针对 iPhone X 屏幕在安全区域内进行布局，并修改相关 Bar 的高度值（见上述表格）。以自定义导航栏适配为例，步骤如下：（1）在每个页面的 page.js 中先读取 app.js 中的 isIPX 值，如下：const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    // 页面其他数据...\r\n    \r\n    isIPX: app.globalData.isIPX,\r\n  },\r\n  \r\n  // 其他代码\r\n}\r\n（2）然后在 page.wxss 样式文件中对某一个视图 View 分别为普通屏幕和 iPhone X 屏幕写两种样式，如下：.navi-bar-view {\r\n  height: 64px;\r\n  /* 其他样式值 */\r\n}\r\n.navi-bar-view-IPX {\r\n  height: 88px;\r\n  /* 其他样式值 */\r\n}\r\n（3）最后在 page.wxml 页面结构布局中根据 isIPX 的值给 View 设置不同的 class 样式，如下：<view class=\"{{isIPX ? 'navi-bar-view-IPX' : 'navi-bar-view'}}\">\r\n</view>\r\n此外，对于自定义导航栏和标签栏，我建议还是要遵循 iPhone UI 的设计规范，样式可以参考苹果官方的渲染图：吸底按钮适配在小程序页面中，吸底按钮是很常见的一种设计，我们一般会把一些重要的按钮放在页面底部悬浮不动，例如我们知识小集小程序的“小集详情页”底部的“收藏”和“转发”按钮：在 iPhone X 中我们需要把吸底按钮往上偏移 34 像素，可通过在 CSS 样式中设置 padding-bottom 为 34px 实现，参考代码如下：.feed-bottom-view {\r\n  width: 100%;\r\n  height: 48px; /* 吸底按钮的高度 */\r\n  bottom: 0;\r\n  opacity: 0.95;\r\n  position: fixed;\r\n  border-top-style: solid;\r\n  border-top-width: 0.5px; /* 分割线的高度 */\r\n  border-color: lightgrey;\r\n  background-color: #F8F8F8;\r\n}\r\n.feed-bottom-view-IPX {\r\n  /* iPhone X 内容往上偏移 34px */\r\n  padding-bottom: 34px;\r\n}\r\n<view class=\"{{isIPX ? 'feed-bottom-view feed-bottom-view-IPX' : 'feed-bottom-view'}}\">\r\n<!-- 底部吸底按区域 -->\r\n</view>\r\n备注：如前面所述，对于不同设备宽度，1rpx 所代表的实际像素值也不一样，而在不同尺寸的 iPhone 设备（3.5/4.0/4.7/5.5 英寸）中，虽然它们的宽度不同，但其导航栏+状态栏的高度都为 64pt（iPhone X 为 88pt），标签栏 TabBar 的高度都为 49pt（iPhone X 为 83pt）。所以在小程序开发中，当我们需要自定义导航栏、标签栏，或者适配 iPhone X 顶部和底部安全区域时，我建议此处的单位直接使用 px （在小程序中对应 iOS 开发中的点 pt ）而不使用 rpx （当然页面的其他元素的尺寸描述还是推荐使用 rpx ），以确保最终渲染显示的高度与 iOS 系统默认的一致。总结本文简要介绍了在小程序开发中如何适配 iPhone X 屏幕，更多细节请查阅我们在 GitHub 上开源的知识小集小程序的代码： awesome-tips-wx-app"}
{"title": "小程序自定义组件-可清除的input组件 ", "author": "Rolan", "pub_time": "2018-7-26 00:15", "content": "最近正在做的一个小程序项目中需要用到一个可清除的输入框控件，为了在项目中使用方便以及方便其他项目直接使用，便封装了一个可清除的input自定义组件。组件需要达到的需求是：输入框内没有内容时，删除按钮隐藏；当输入框内有内容时，删除按钮显示，点击删除按钮则清空输入框内所有内容。并且还可以设置输入框整体样式以及输入框左侧图标。明确了需求之后，就可以开始着手实现了。首先，在目标目录下新建一个自定义组件建好之后，我们需要来设计布局。根据需求来看，我们只需要三个组件：两个image和一个input。左边一个image提示图标，然后一个input输入框，最后一个image删除按钮。我们要把尽可能多的数据设置成可以修改的绑定数据，提高自定义组件的可扩展性。最终确定的wxml布局文件如下：<view class='input-class'>\r\n     <image src='{{inputIcon}}' mode=\"scaleToFill\" class='icon-class'></image>\r\n     <input placeholder='{{inputHint}}' bindconfirm='{{confirmTap}}' style='flex:1;width:100%;padding-left:12rpx;' bindinput='inputListener' bindconfirm='inputConfirm' value='{{inputValue}}' type='{{inputType}}' password='{{isPassword}}' confirm-type='{{confirmType}}'></input>\r\n     <image class=\"{{isClearShow?'clearImgShow':'clearImgHide'}}\" src='clear.png' bindtap='clearTap' mode='widthFix'></image>\r\n</view>然后，我们就要来设置组件的一些属性和监听方法了。小程序的组件属性列表是定义在.js文件的properties里的。把需要暴露出去并可以修改的属性都写在这里面。其语法示例如下：properties: {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）\r\n      value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个\r\n      observer: function(newVal, oldVal, changedPath) {\r\n         // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'\r\n         // 通常 newVal 就是新设置的数据， oldVal 是旧数据\r\n      }\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  }我的属性列表如下：     /**\r\n      * 组件的属性列表\r\n      */\r\n     properties: {\r\n          inputHint: {\r\n               type: String,\r\n               value: '搜索'\r\n          },\r\n          inputIcon: {\r\n               type: String,\r\n               value: 'search.png'\r\n          },\r\n          inputType: {\r\n               type: String,\r\n               value: 'text'\r\n          },\r\n          isPassword: {\r\n               type: Boolean,\r\n               value: false\r\n          },\r\n          confirmType: {\r\n               type: String,\r\n               value: \"done\"\r\n          }\r\n     }完成了属性列表的编写之后，接下来我们需要为自定义组件添加监听事件。事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。监听以及触发事件的语法是这样的：//触发事件\r\n//自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail对象和事件选项\r\nmethods: {\r\n    onTap: function(){\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    }\r\n  }\r\n\r\n//监听事件\r\n<!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->\r\n<component-tag-name bindmyevent=\"onMyEvent\" />\r\n<!-- 或者可以写成 -->\r\n<component-tag-name bind:myevent=\"onMyEvent\" />这里我们需要设置的触发事件有，输入框的输入事件以及输入框的确认事件。通过 triggerEvent 方法指定事件名以及事件触发事件参数     /**\r\n      * 组件的方法列表\r\n      */\r\n     methods: {\r\n          inputListener: function (e) {\r\n               var value = e.detail.value;\r\n               var cursor = e.detail.cursor;\r\n               if (value === null || value === undefined || value.length === 0) {\r\n                    this.setData({\r\n                         isClearShow: false\r\n                    });\r\n               } else {\r\n                    this.setData({\r\n                         isClearShow: true\r\n                    });\r\n               }\r\n               var detail = {\r\n                    value: value,\r\n                    cursor: cursor\r\n               };\r\n               this.triggerEvent('inputListener', detail);\r\n          },\r\n\r\n          inputConfirm: function (e) {\r\n               var value = e.detail.value;\r\n               var detail = {\r\n                    value: value\r\n               }\r\n               this.triggerEvent('inputConfirm', detail);\r\n          },\r\n\r\n          clearTap: function () {\r\n               this.setData({\r\n                    isClearShow: false,\r\n                    inputValue: ''\r\n               });\r\n          }\r\n     }以上就已经完成了这个可清除input组件的自定义开发了。现在来看怎么使用这个组件。首先在需要使用此组件的页面.json文件中设置usingComponents属性来引入这个自定义组件     \"usingComponents\": {\r\n          //这里是设置的组价标签名称以及组件地址\r\n          \"clearInput\": \"../../components/clearInput/clearInput\"\r\n     }然后，我们就可以在页面中引用这个自定义组件了，引用的方式非常简单，通过我们在上一步设置的标签名称就可以引用了。<clearInput inputHint='搜索订单' icon-class='common_search_img' input-class='common_search_input' confirmType='search' bind:inputListener='inputListener' bind:inputConfirm='searchEvent' />最终实现的效果图如下：项目GitHub地址：https://github.com/RaoMeng/TemplateOfHotel"}
{"title": "微信小程序 - 前三排名实现 ", "author": "Rolan", "pub_time": "2018-7-27 00:09", "content": "实现原理：利用背景图片以及nth-child实现 作者：Sunsin原文：http://www.cnblogs.com/cisum/p/9370248.html"}
{"title": "微信小程序使用相机 ", "author": "Rolan", "pub_time": "2018-7-27 00:15", "content": "<view class=\"page-body\">  <view class=\"page-body-wrapper\">    <camera device-position=\"back\" flash=\"off\" binderror=\"error\" style=\"width: 100%; height: 300px;\"></camera>    <view class=\"btn-area\">      <button type=\"primary\" bindtap=\"takePhoto\">拍照</button>    </view>    <view class=\"btn-area\">      <button type=\"primary\" bindtap=\"startRecord\">开始录像</button>    </view>    <view class=\"btn-area\">      <button type=\"primary\" bindtap=\"stopRecord\">结束录像</button>    </view>    <view class=\"preview-tips\">预览</view>    <image wx:if=\"{{src}}\" mode=\"widthFix\" src=\"{{src}}\"></image>    <video wx:if=\"{{videoSrc}}\" class=\"video\" src=\"{{videoSrc}}\"></video>  </view></view>  onLoad() {    this.ctx = wx.createCameraContext()  },  takePhoto() {    this.ctx.takePhoto({      quality: 'high',      success: (res) => {        this.setData({          src: res.tempImagePath        })      }    })  },  startRecord() {    this.ctx.startRecord({      success: (res) => {        console.log('startRecord')      }    })  },  stopRecord() {    this.ctx.stopRecord({      success: (res) => {        this.setData({          src: res.tempThumbPath,          videoSrc: res.tempVideoPath        })      }    })  },  error(e) {    console.log(e.detail)  }/* pages/one/one.wxss */.preview-tips {  margin: 20rpx 0;  }.video {  margin: 50px auto;  width: 100%;  height: 300px;}"}
{"title": "微信小程序--旋转木马/缩放轮播图效果 ", "author": "Rolan", "pub_time": "2018-7-27 00:21", "content": "话不多说先上图.gif文章涉及技术点微信小程序原生Swiper控件\r\nWxss Transform、Transition\r\n轮播条滚动回调控制\r\n微信小程序条件渲染、列表渲染\r\n全部实现代码加起来也就三四十行，大部分还用来写wxml UI代码，所以功能实现起来非常简单。 首先将问题简单化，能用原生组件实现出我们想要的效果，绝不自己开发Component。原因：我懒+我自己写的也不敢说性能堪比原生组件先来分析一波gif中我们需要实现效果和哪些效果可以直接修改原生Swiper的属性就能实现的我们需要自己实现的功能自动滚动+手动拖拽 （原生组件帮我们完成 Property：autoplay） 面板指示点 （原生组件帮我们完成 Property：indicator-dots） 左右可以露出非Active状态图的边缘（即Quiet状态， 后文class会以这两个名字定义） （原生组件帮我们完成 Property：previous-margin、next-margin） 图片滚动到中心位置放大，滚动出去缩小 （我们手写实现，利用技术点中提到的滚动回调+条件渲染。其中滚动回调用 Property：bindchange） 这样看下来就很清晰了，需要我们实现的只有一个动画放大缩小。再进一步就能分成两种实现方式:wxss实现 js实现很显然wxss实现代码很少也能达到同样的效果，so~//.wxml  <swiper class='swiperClass' autoplay indicator-color=\"#a39f99\" indicator-active-color=\"#f49641\" indicator-dots  interval=\"2000\" duration=\"1000\" previous-margin=\"30px\" next-margin=\"30px\" circular bindchange=\"bindchange\" style='height: {{swiperHeight}}px'>    <block wx:for=\"{{imgUrls}}\" wx:key=\"{{index}}\">      <swiper-item>        <image src=\"{{item}}\" class=\"slide-image {{swiperIndex == index ? 'active' : 'quiet'}}\" mode='aspectFill'>        </image>      </swiper-item>    </block>  </swiper>//.wxss.swiperClass {  margin: 0;  margin-top: 10px;}.slide-image {  width: 100%;  height: 90%;  border-radius: 10px;  position: relative;}image.active {  transform: none;  transition: all 0.2s ease-in 0s;}  image.quiet {  transform: scale(0.8333333);  transition: all 0.2s ease-in 0s;}//.jsdata: {    imgUrls: [      'xxx',      'xxx',      'xxx',      'xxx'    ],    swiperIndex: 0 //这里不写第一次启动展示的时候会有问题  },bindchange(e) {    this.setData({      swiperIndex: e.detail.current    })  },上面Swiper控件里面还有设置宽高的属性就随便填几个数测试就好了，不影响主要功能。注意身体，小心秃顶"}
{"title": "简易商城小程序全栈开发(mpvue+koa+mongodb) ", "author": "Rolan", "pub_time": "2018-7-27 00:24", "content": "接触小程序有一段时间后并且多多少少做了一些项目之后，又开始了vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue 是一个使用 Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点vue.js的开发体验。技术栈前端： 微信小程序、mpvue后端：koa数据库：mongodb 数据库可视化工具：Robo3T商城小程序开跑一个基本的商城小程序，包含了前端的首页、分类、购物车、我的(订单)四个tab页，后端的数据定义、分类、和存取。各有其色，我在下面就相应介绍一些主要功能、对比原生小程序和vue.js所踩到的坑还有后端数据库的功能应用。 想了解或者有何问题都可以去 作品源码 中了解哦。成果分享一、前台页面及功能展示首页：加入购物车：购物车全选结算：地址管理：1. 谈组件封装举个栗子说，首页由三部分组成:头部轮播推荐+中间横向滑动推荐+纵向滚动商品list。这三部分，几乎是所有商城类app必需的功能了。头部的轮播推荐、中间的横向滑动式推荐的封装，我们都知道，诸如此类的功能组件，在各app上基本都少不了，最初学vue最先有所体会的，便是组件代码复用性高的特点，在进行一些组件复用迁移至别的组件或页面时，可能都不需要改动代码或者改动少量代码就可以直接使用，可以说是相当方便了，对于mpvue组件内仍然支持原生小程序的swiper与scroll，两者兼容后，对于熟知小程序和vue的开发者，这项功能可以很高效率地完成。最后主页面文件就是由一个个组件组成，可读性很强了，对于初学者来说，模块封装的思想是首先就得具备的了。<template>\r\n  <div class=\"container\" @click=\"clickHandle('test click', $event)\">\r\n    <div class=\"swiperList\">\r\n      <swiper :text=\"motto\" :swiperList=\"swiperlist\"></swiper>\r\n    </div>\r\n    <div class=\"navTab\">\r\n      <div class=\"recTab\">\r\n        <text>  ——  为你推荐  ——</text>\r\n    </div>\r\n    </div>\r\n    <scroll></scroll>\r\n    <div class=\"hot\">\r\n      <span> —— 热门商品 ——</span>\r\n    </div>\r\n    <hot :v-text=\"motto\"></hot>\r\n    <div class=\"fixed-img\">\r\n      <img :src=\"fixImg\" alt=\"\" class=\"fix-img\">\r\n    </div>\r\n  </div>\r\n</template>\r\n复制代码不过关于组件封装与组合的问题，由于最近有研究vue性能优化和用户体验的一些知识点，考虑了一个比较严肃的问题：先看一下常见的vue写法：在html里放一个app组件，app组件里又引用了其他的子组件，形成一棵以app为根节点的组件树：<body>\r\n    <app></app> \r\n</body>\r\n复制代码而这种做法就引发了性能问题，要初始化一个父组件，必然需要先初始化它的子组件，而子组件又有它自己的子组件。那么要初始化根标签，就需要从底层开始冒泡，将页面所有组件都初始化完。所以我们的页面会在所有组件都初始化完才开始显示。这个结果显然不是我们要的，用户每次点开页面，还要面对一阵子的空白和响应，因为页面启动后不止要响应初始化页面的组件，还有包含在app里的其他组件，这样严重拖慢了页面打开的速度。更好的结果是页面可以从上到下按顺序流式渲染，这样可能总体时间增长了，但首屏时间缩减，在用户看来，页面打开速度就更快了。网上一些办法大同小异，各有优缺点，所以...本人也在疯狂试验中，静待好消息。**2.Class、Style的绑定 **在不同父组件中引用同一子组件时，但是各自需要接收绑定的动态样式去呈现不同的样式，在绑定css style样式这一关上，踩了个大坑：mpvue居然不支持用object的形式传style，起先处于样式一直上不去的抓狂当中,网上对于mpvue这方面的细节也少之又少，后来查找了许多地方，发现class和style的绑定都是不支持classObj和styleObj形式，就尝试用了字符串，果然...改代码改到怀疑人生，结果你告诉我人生起步就是错误，怎能不心痛？...解决：<template>\r\n<div class=\"swiper-list\">\r\n    <d-swiper :swiperList=\"swiperlist\" :styleObject=\"styleobject\"></d-swiper>\r\n</div>\r\n</template>\r\n<script>\r\n    data() {\r\n        return {\r\n            styleobject:'width:100%;height:750rpx;position:absolute;top:0;z-index:3'\r\n        }\r\n    }\r\n</script>\r\n复制代码3. “v-for嵌套”陷阱在做vue项目的时候难免会用到循环，需要用到index索引值，但是v-for在嵌套时index没办法重复用，内循环与外循环不能共用一个index。<swiper-item v-for=\"(items,index) in swiperList\" :key=\"index\">\r\n    <div v-for=\"item in items\" class=\"swiper-info\" :key=\"item.id\" @click=\"choose\" >\r\n        <image :src=\"item.url\"  class=\"swiper-image\" :style=\"styleObject\"/>\r\n    </div>\r\n</swiper-item>\r\n复制代码以上代码就会报错：而给内循环再加上另一个索引，便没有报错：<swiper-item v-for=\"(items,index) in swiperList\" :key=\"index\">\r\n    <div v-for=\"(item,i) in items\" class=\"swiper-info\" :key=\"i\" @click=\"choose\" >\r\n        <image :src=\"item.url\"  class=\"swiper-image\" :style=\"styleObject\"/>\r\n    </div>\r\n</swiper-item>\r\n复制代码4.this指向问题与箭头函数的应用这是vue文档里的原话：All lifecycle hooks are called with their 'this' context pointing to the Vue instance invoking it.意思是：在Vue所有的生命周期钩子方法（如created，mounted， updated以及destroyed）里使用this，this指向调用它的Vue实例，即（new Vue）。 mpvue里同理。 我们都知道，生命周期函数中的this都是指向Vue实例的，因此我们就可以访问数据，对属性和方法进行运算。props：{\r\n    goods:Array\r\n},\r\nmounted: function(options){\r\n    let category = [\r\n      {id: 0, name: '全部'},\r\n      {id: 1, name: 'JAVA'},\r\n      {id: 2, name: 'C++'},\r\n      {id: 3, name: 'PHP'},\r\n      {id: 4, name: 'VUE'},\r\n      {id: 5, name: 'CSS'},\r\n      {id: 6, name: 'HTML'},\r\n      {id: 7, name: 'JavaScript'}\r\n    ]\r\n    this.categories = category\r\n    this.getGoodsList(0)\r\n  },\r\nmethods: {\r\n    getGoodsList(categoryId){\r\n      console.log(categoryId);\r\n      if(categoryId == 0){\r\n        categoryId = ''\r\n      }\r\n      wx.request({\r\n        url: 'http://localhost:3030/shop/goods/list',\r\n        data: {\r\n          categoryId: categoryId\r\n        },\r\n        method: 'POST', \r\n        success: res => {\r\n          console.log(res);\r\n          this.goods = res.data.data;\r\n        }\r\n      })\r\n    },\r\n}\r\n复制代码普通函数this指向这个函数运行的上下文环境，也就是调用它的上下文，所以在这里，对于生命周期函数用普通函数还是箭头函数其实并没有影响，因为它的定义环境与运行环境是同一个，所以同样能取到vue实例中数据、属性和方法。 箭头函数中，this指向的是定义它的最外层代码块，()=>{} 等价于 function(){}.bind(this);所以this当然指向的是vue实例。起初并没有考虑到this指向的问题，在wx.request({})中success用了普通函数，结果一直报错“goods is not defined”，用了箭头函数才解决，起初普通函数的this指向 getGoodsList()的上下文环境，所以一直没办法取到值。5.onLoad与onShow在进行首页点击商品跳转到详情页时，onLoad()无法获取更新数据。首先虽然onLoad: function (options) 这个是可以接受到值的，但是这个只是加载一次，不是我想要的效果，我需要在本页面(不关闭的情况下)到另外一个页面在跳转进来，接收到对应商品的数据。所以需要将代码放在onshow内部， 在每次页面加载的时候都会进行当前状态的查询，查询对应数据的子对象，更新渲染到详情页上。onShow: function(options){\r\n    // console.log(this.styleobject)\r\n      // console.log(options)\r\n    wx.getStorage({\r\n      key: 'shopCarInfo',\r\n      success: (res) =>{\r\n        // success\r\n        console.log(`initshopCarInfo:${res.data}`)\r\n        this.shopCarInfo = res.data;\r\n        this.shopNum = res.data.shopNum\r\n      }\r\n    })\r\n    wx.request({\r\n      url: 'http://localhost:3030/shop/goods/detail',//请求detail数据表的数据\r\n      method: 'POST',\r\n      data: {\r\n        id: options.id\r\n      },\r\n      success: res =>{\r\n        // console.log(res);\r\n        const dataInfo = res.data.data.basicInfo;\r\n        this.saveShopCar = dataInfo;\r\n        this.goodsDetail.name = dataInfo.name;\r\n        this.goodsDetail.minPrice = dataInfo.minPrice;\r\n        this.goodsDetail.goodsDescribe = dataInfo.characteristic;\r\n\r\n        let goodsLabel = this.goodsLabel\r\n        goodsLabel = res.data.data;\r\n        // console.log(goodsLabel);\r\n        this.selectSizePrice = dataInfo.minPrice;\r\n        this.goodsLabel.pic = dataInfo.pic;\r\n        this.goodsLabel.name = dataInfo.name;\r\n        this.buyNumMax = dataInfo.stores;\r\n        this.buyNumMin = (dataInfo.stores > 0) ? 1 : 0;\r\n      }\r\n    })\r\n  }\r\n复制代码了解小程序onLoad与onShow生命周期函数：onLoad：生命周期函数–监听小程序初始化，当小程序初始化完成时，会触发 onLoadh（全局只触发一次）。onShow：生命周期函数–监听小程序显示，当小程序启动，或从后台进入前台显示，会触发 onShow。二、后台数据库及数据存取1.架设 HTTP 服务在全局配置文件中： 1).引入koa并实例化const Koa = require('koa')；\r\nconst app = new Koa()\r\n复制代码2).app.listen(端口号)：创建并返回 HTTP 服务器，将给定的参数传递给Server#listen()。const Koa = require('koa');//引入koa框架\r\nconst app = new Koa();\r\napp.listen(3000);\r\n这里的app.listen()方法只是以下方法的语法糖:\r\n\r\nconst http = require('http');\r\nconst Koa = require('koa');\r\nconst app = new Koa();\r\nhttp.createServer(app.callback()).listen(3000);\r\n复制代码这样基本的配置完毕，我们就可以用“http://localhost3030+请求地址参数”获取到数据库的值了。2.Koa-router路由中间件koa-router 是常用的 koa 的路由库。如果依靠ctx.request.url去手动处理路由，将会写很多处理代码，这时候就需要对应的路由的中间件对路由进行控制，这里介绍一个比较好用的路由中间件koa-router。以路由切换催动界面切换，”数据化”界面。3.建立对象模型在构建函数库之前，先来聊聊对象的建模。Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具。该npm包封装了操作mongodb的方法。Mongoose有两个特点：1、通过关系型数据库的思想来设计非关系型数2、基于mongodb驱动，简化操作const mongoose = require('mongoose')\r\n\r\nconst db = mongoose.createConnection('mongodb://localhost/shop') //建立与shop数据库的连接(shop是我本地数据库名)\r\n复制代码本地数据库shop中建了分别“地址管理”、“商品详情”、“订单详情”、“商品列表”、“用户列表”五个数据表：Schema界面定义数据模型：Schema用于定义数据库的结构。类似创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection，但是Schema不具备操作数据库的能力。数据表跟对象的映射,同时具有检查效果,检查每组数据是否满足模型中定义的条件 同时，每个对象映射成一个数据报表，就可用该对象进行保存操作，等同操作数据表，而非mysql命令行般繁琐的操作以“商品列表”数据表为例：// 模型通过Schema界面定义。\r\nvar Schema = mongoose.Schema;\r\n\r\nconst listSchema = new Schema({\r\n  barCode: String,\r\n  categoryId: Number,\r\n  characteristic: String,\r\n  commission: Number,\r\n  commissionType: Number,\r\n  dateAdd: String,\r\n  dateStart: String,\r\n  id: Schema.Types.ObjectId,\r\n  logisticsId: Number,\r\n  minPrice: Number,\r\n  minScore: Number,\r\n  name: String,\r\n  numberFav: Number,\r\n  numberGoodReputation: Number,\r\n  numberOrders: Number,\r\n  originalPrice: Number,\r\n  paixu: Number,\r\n  pic: String,\r\n  pingtuan: Boolean,\r\n  pingtuanPrice: Number,\r\n  propertyIds: String,\r\n  recommendStatus: Number,\r\n  recommendStatusStr: String,\r\n  shopId: Number,\r\n  status: Number,\r\n  statusStr: String,\r\n  stores: Number,\r\n  userId: Number,\r\n  videoId: String,\r\n  views: Number,\r\n  weight: Number,\r\n})\r\n\r\n复制代码定义了数据表中需要的数据项的类型，数据表传入数据后会一一对应：4.koa-router“路由库”const Router = require('koa-router')()//引入koa-router\r\nconst router = new Router();// 创建 router 实例对象\r\n//注册路由\r\nrouter.post('/shop/goods/list', async (ctx, next) => {\r\n  const params = ctx.request.body\r\n  //以‘listSchema’的模型去取到Goods的数据\r\n  const Goods = db.db.model('Goods', db.listSchema) //第一个‘db’是require来的自定义的，第二个‘db’是取到连接到mongodb的数据库，model代指实体数据(根据schema获取该字段下的数据，然后传给Goods))\r\n  ctx.body = await new Promise((resolve, reject) => {//ctx.body是ctx.response.body的缩写,代指响应数据\r\n    //异步，等到获取到数据之后再将body发出去\r\n    if (params.categoryId) {\r\n      Goods.find({categoryId: params.categoryId},(err, docs) => {\r\n        if (err) {\r\n          reject(err)\r\n        }\r\n        resolve({\r\n          code: 0,\r\n          errMsg: 'success',\r\n          data: docs\r\n        })\r\n      })\r\n    } else {\r\n      Goods.find((err, docs) => {\r\n        if (err) {\r\n          reject(err)\r\n        }\r\n        resolve({\r\n          code: 0,\r\n          errMsg: 'success',\r\n          data: docs\r\n        })\r\n      })\r\n    }\r\n  })\r\n})\r\n复制代码所有的数据库操作都是异步的操作，所以需要封装promise来实现，由此通过POST “http://localhost3030/shop/goods/list”便可访问本地shop数据库了。 这里顺便提一下“ctx”的使用，ctx(context)上下文，我们都知道有node.js 中有request(请求)对象和respones(响应)对象。Koa把这两个对象封装在ctx对象中。 参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response (前端通过ajax请求http获取数据) 我们可以通过ctx请求or获取数据库中的数据。Ctx.body 属性就是发送给用户的内容body是http协议中的响应体，header是指响应头ctx.body = ctx.res.body = ctx.response.body5.数据缓存之模型层设置1).为什么要做数据缓存？在这里不得不提一句数据缓存的重要性，虽然我是从本地数据库获取的数据，但是由于需要的数据量较多，再者前面说的性能优化还未完成，每次还是有一定的请求时间，没必要每次打开都去请求一遍后端，渲染页面较慢，所以需要将需要经常用到的数据做本地缓存，这样能大大提高页面渲染速度。2).设置模型层setGoodsList: function (saveHidden, total,  allSelect, noSelect, list) {\r\n      this.saveHidden = saveHidden,\r\n      this.totalPrice = total,\r\n      this.allSelect = allSelect,\r\n      this.noSelect = noSelect,\r\n      this.goodsList = list\r\n      var shopCarInfo = {};\r\n      var tempNumber = 0;\r\n      var list = [];\r\n      shopCarInfo.shoplist = list;\r\n\r\n      for (var i = 0; i < list.length; i++) {\r\n        tempNumber = tempNumber + list[i].number\r\n      }\r\n      shopCarInfo.shopNum = tempNumber;\r\n      wx.setStorage({\r\n        key: \"shopCarInfo\",\r\n        data: shopCarInfo\r\n      })\r\n    },\r\n\r\n复制代码将需要做本地存储数据的方法封装成一个方法模型，当需要做本地存储时，直接做引用，如今vue、react中多用到的架构思想，都对模型层封装有一定的要求。bindAllSelect() {\r\n      var list = this.goodsList;\r\n      var currentAllSelect = this.allSelect\r\n      if (currentAllSelect) {\r\n        list.forEach((item) => {\r\n          item.active = false\r\n        })\r\n      } else {\r\n        list.forEach((item) => {\r\n          item.active = true\r\n        })\r\n      }\r\n      this.setGoodsList(this.getSaveHide(), this.totalPrice(), !currentAllSelect, this.noSelect(), list);\r\n    },\r\n复制代码结语：写这个项目抓狂了很多次，因为很多vue能用的但在mpvue里实现不了，导致走了很多弯路，踩了很多坑，但是程序猿成长不就是在一个个坑里掉下去又爬起来的过程中吗？作文不易，伙伴们能打赏点就打赏点吧... 顺便附上我的项目地址： “mpvue-demo” ，不过还有很多需要完善的地方，漫漫长路一起走啊！作者：mosa原文：https://juejin.im/post/5b548ce8e51d45191d79f8a6?utm_source=tuicool&utm_medium=referral"}
{"title": "解决微信小游戏排行榜 Android 模糊问题 ", "author": "Rolan", "pub_time": "2018-7-30 00:08", "content": "最近用 Cocos Creator (cc) 开发微信小游戏。由于 微信小游戏存在 主域和子域的隔离；主域，你的主要游戏场景，和一些交互按钮等内容；子域，主要用于获取用户数据和排行榜的显示；微信这样分开也是为了更好地保护用户数据，防止数据泄露。因此一定要合理的设计自己的主域和子域；凡是设计从微信里获取数据的比如用户头像，游戏成绩等；一定需要在子域的canvas 完成绘制；实际在完成排行榜的功能时候遇到了一点兼容性的问题，Android 的部分机型(自己这边全部复现)和 iOS 设备上存在画布模糊的问题:ios 的截图如下:搜索了一下，发现没有多少人提出这样的问题，但是看别的游戏也存在同样的问题；不过，灵机一动！！！如果前端接触 canvas 的话，才开始都会遇到一个问题，就是再 PC 上看着挺好的，但是在移移动端就模糊了，因为这里存在一个 设备上物理像素和设备独立像素(device-independent pixels (dips))的比例 因此你的 canvas 设置的像素要比实际多出一些比如会有:canvas.width = window.innerWidth * window.devicePixelRatio  \r\n于是照着这个思路，输出了 主域的 canvas 宽度 和 子域的 canvas 宽度，发现 子域的 sharedCanvas 并不是你预期的宽度，因此这个时候你需要手动的将它设置成你在 cocos creator 设置的画布大小比如 750 * 1662 等；if (typeof sharedCanvas !== 'undefined') {  \r\n  sharedCanvas.width = 750\r\n  sharedCanvas.height = 1662\r\n}\r\n大概完成后就不会有模糊的感觉了~"}
{"title": "微信小程序demo视频：博卡君开发实操指南 ", "author": "天下雪", "pub_time": "2016-10-14 10:16", "content": "经过国庆节的七天假期，相信很多朋友都已经研究出自己的小程序 demo 了吧？我最近也利用休息时间关注了一下网上关于小程序开发的讨论，今天就利用这个番外篇谈谈自己对小程序的一些想法吧，顺便把目前做好的成品 demo 给大家看一看。\r\n　　很多学编程的朋友最关心的问题就是小程序的开发难度。我个人觉得，微信小程序的开发难度不算高，最主要的是要时时刻刻遵守微信给我们划定的一些框架和规范。如果你有前端开发基础，那上手会非常快，相比之下，原生APP开发难度就大了很多。　　在用户体验方面，其实微信小程序开发和原生APP在体验方面在日常应用中可以做到非常接近了。不同点就是，微信小程序开发学习周期比较快，开发周期较短，维护起来也快，而原生APP的开发需要全部重新学习它的语言，学习周期很长，开发周期也很长，同时发布需要很长时间的审核期，在迭代方面速度比较慢。　　对于做前端的朋友，适应小程序最需要完成一个开发理念上的大转变，从操作 DOM 转变为操作数据，项目组件化、模板化，需要使用的组件直接调用。换言之，小程序绝对不是「Html 5 + javascrpt 封装一下」那么简单，为了让用户体验更加接近原生 APP，腾讯专门开放了大量接口和组件，这些都是 Html 本身所不具备的。我在一开始接触到这些东西的时候，也琢磨了很久才渐渐适应小程序的节奏。　　有朋友也问过，博卡君连夜吐血赶工了近两周才基本完成一个小程序，是不是微信小程序的开发工作量比较大，我觉得这要具体看你的项目重不重，轻量型的项目团队开发只需要一两周，但也可能在开发中碰到很多需要攻克的技术难点。此外，如果你的需求一直在变化，或者与不熟练的队友在开发，都是有可能影响进度。博卡君吐血熬夜毕竟是为了第一时间同时完成开发和教程的进度，如果团队协作，应该不需要这么辛苦?。　　最后谈一点，博卡君在这个项目中一直是以个人开发者的角色来做的，对于想跟博卡君一样独立开发的朋友，我个人觉得，如果你有数据支持，而且懂后台开发和Mysql，那完全不妨一试。　　好了，博卡君的全球首个微信小程序教程到这里就完全结束了，谢谢大家一直以来的支持和关注。最近大家都在期待微信官方的动态，毕竟目前既不能提交已经做好的小程序，也不确定微信会不会有小程序商店之类的入口来体验成品，博卡君也利用国庆长假顺带关注了一下 iMessage 插件的开发，看看其它平台有没有适合自己发挥的空间。　　其实关注 iMessage 最主要的原因还是它跟微信小程序有许多相似之处，譬如两者都是聊天工具的内部程序、都切合轻量化的使用场景、对 Html 5 都有很好的支持等。我这两天也尝试做了一款 iMessage APP，等功能完善之后会把成品放出来给大家看看。大家也可以对比一下两者的异同，选择适合自己的开发方向。"}
{"title": "微信小程序技术教程：集成 Redux ", "author": "天下雪", "pub_time": "2016-10-15 21:48", "content": "示例Redux是什么Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux官方文档为什么要使用Redux小程序俨然是一个类似Hybrid App的东西，前面是SPA，小程序提供一些原生功能的接口。现在前端程序规模都比较大，页面状态，数据缓存，需要管理的东西太多。引入Redux可以方便的管理这些状态。并且Redux丰富的周边工具也是很有吸引力的。集成Redux小程序的模块化微信的文档并没有指出如何使用第三方库，所以只能从微信小程序的模块化入手。文档中提到，模块化的关键是：module.exports = function(){}同时，如果我们去观察小程序开发环境的network面板，点击任何一个js，我们可以发现：项目目录中的所有js文件都会自动被加载，无论我们是否在代码中require所以的模块都会被套上下面的代码：define(\"reducers/visibilityFilter.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;/*******************//******你写的代码******/                                                                 /********************/})这实际上是类似AMD的加载方式，但是跟标准的AMD又有些不同，缺少了依赖部分的声明。function(require, module){}: 这个函数包裹的是模块的实现，也就是我们自己写的代码，小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去：module.exports = function(){}所以只要需要让第三方库的代码使用这种形式的export就可以了。构建Redux的微信小程序包这里主要目标是打一个Redux包，让它可以兼容微信小城的加载方式下载Redux的代码到本地：git clone https://github.com/reactjs/redux.git安装依赖：npm install打包：npm run build:umd && npm run build:umd这些命令的详细内容可以到redux项目的package.json中查看。这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到。带min.js后缀的是minify过的。      4.微调加载方式：用编辑器打开dist目录下的redux.js文件(function webpackUniversalModuleDefinition(root, factory) {    if(typeof exports === 'object' && typeof module === 'object')        module.exports = factory();    else if(typeof define === 'function' && define.amd)        define([], factory);    else if(typeof exports === 'object')        exports[\"Redux\"] = factory();    else        root[\"Redux\"] = factory();})(this, function() {...  })这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来。将第二行代码：if(typeof exports === 'object' && typeof module === 'object')      修改成：if(typeof module === 'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入了拷贝进工程目录例如，我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了：var redux = require('./libs/redux.js')通过这里的示例，其实我们发现，我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了。使用Redux我们可以使用Redux的微信小程序绑定库来简化一些代码：wechat-weapp-redux，详细的安装和使用说明可以参照wechat-weapp-redux的README集成Redux-devtools如果没有redux-devtools那么使用redux的效果可能是要减半的。因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件。这里使用remote-redux-devtools，remotedev-server安装remote-redux-devtools原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现。修改好的包在这里：remote-redux-devtools把代码下载到工程目录里面就可以用了。安装和启动remotedev-servernpm install -g remotedev-serverremotedev --hostname=localhost --port=5678          因为没办法用npm安装到本地（开头提到的，微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678。     3.  集成devtoolconst {createStore, compose} = require('./libs/redux.js');const devTools = require('./libs/remote-redux-devtools.js').default;const reducer = require('./reducers/index.js')function configureStore() {  return createStore(reducer, compose(devTools({    hostname: 'localhost',    port: 5678,    secure: false  })));}module.exports = configureStore;把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了      4.  打开监视器          可以在浏览器中访问localhost:5678，这是remotedev-server自带的监视器，正常打开的话是这样的：          左边有一个@@INIT说明小程序的redux连接成功了。但是这里这个自带的监视器可能打不开，因为它的一些js包是存在国外的cdn上的，偶尔访问不到。这个时候可以使用http://remotedev.io/local/，点击下面的setting，设置使用本地的server。保存之后刷新页面，应该跟上面显示的结果一样。示例详细的代码示例，可以参照：wechat-weapp-redux-todos"}
{"title": "微信小程序学习点滴《三》：开发工具及开发环境配置，尺寸单位rpx与px,rem相互转换 ... ", "author": "天下雪", "pub_time": "2016-10-17 13:11", "content": "一：开发工具及开发环境配置1.开发工具下载地址Windows 64位 下载Windows 32位 下载MacOS 下载2.安装过程对于Windows用户直接双击下一步的方式安装即可，此处注意我们使用的版本是官方最新的版本（不需要破解），可以不用AppID，也就是说没有资格的开发者也可以测试。2.1 环境测试以及演示项目2.1.1安装完成过后通过打开我们已经完成的应用测试环境是否正常2.1.2开发者工具安装完成后，打开并使用微信扫码登录。2.1.3选择创建“项目”，填入你在公众平台的`AppID`，如果没有的话可以点击`无AppID`。2.1.4设置一个本地项目的名称（非小程序名称），比如`WeApp Demo`，并选择一个本地文件夹作为存储目录。点击\"添加项目\"2.2  接下来点击`新建项目`就可以在主界面中预览到示例项目了二：尺寸单位rpx与px,rem相互转换1. rpx :微信小程序开发中新出了尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。微信官方建议视觉稿以iPhone 6为标准.2.rem rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。微信小程序开发尺寸单位文档"}
{"title": "秀杰实战教程系列《四》：倒计时组件，LXStepper组件-商品数量加减 ... ", "author": "天下雪", "pub_time": "2016-10-18 16:22", "content": "一：倒计时组件：适用于电商应用的限时团购、商品秒杀等先来看下最终效果：git源：http://git.oschina.net/dotton/CountDown分步骤-性子急的朋友，可以直接看最后那段代码。wxml文件放个text<text>second: {{second}} micro second:{{micro_second}}</text>在js文件中调用function countdown(that) {  var second = that.data.second  if (second == 0) {    // console.log(\"Time Out...\");    that.setData({      second: \"Time Out...\"    });    return ;  }  var time = setTimeout(function(){    that.setData({      second: second - 1    });    countdown(that);  }  ,1000)}Page({    data: {        second: 3    },    onLoad: function() {        countdown(this);    }});运行验证下，从10走到1s，然后显示时间到。于是继续将毫秒完善，注意毫秒的步长受限于系统的时间频率，于是我们精确到0.01s即10msjs/* 秒级倒计时 */function countdown(that) {  var second = that.data.second  if (second == 0) {    that.setData({      second: \"Time out!\",      micro_second: \"micro_second too.\"    });    clearTimeout(micro_timer);    return ;  }  var timer = setTimeout(function(){    that.setData({      second: second - 1    });    countdown(that);  }  ,1000)}/* 毫秒级倒计时 */// 初始毫秒数，同时用作归零var micro_second_init = 100;// 当前毫秒数var micro_second_current = micro_second_init;// 毫秒计时器var micro_timer;function countdown4micro(that) {  if (micro_second_current <= 0) {    micro_second_current = micro_second_init;  }  micro_timer = setTimeout(function(){    that.setData({      micro_second: micro_second_current - 1    });    micro_second_current--;    countdown4micro(that);  }  ,10)}Page({    data: {        second: 2,        micro_second: micro_second_init    },    onLoad: function() {        countdown(this);        countdown4micro(this);    }});wxml文件<text style=\"display: block;\">second: {{second}}s</text><text>{{micro_second}}</text>如此，当秒级运行完毕时，毫秒级timer即clearTimeout，并将字本显示为'micro_second too'再添加一个countdown4micro方法，使得显示剩余 0:3:19 89这样形式的倒数function dateformat(second) {    var dateStr = \"\";    var hr = Math.floor(second / 3600);    var min = Math.floor((second - hr * 3600) / 60);    var sec = (second - hr * 3600 - min * 60);// equal to => var sec = second % 60;    dateStr = hr + \":\" + min + \":\" + sec;    return dateStr;}目前有2个时钟，影响性能，合并下去掉countdown，于是countdown4micro变成以下的样子：function countdown4micro(that) {    var loop_second = Math.floor(loop_index / 100);    // 得知经历了1s    if (cost_micro_second != loop_second) {        // 赋予新值        cost_micro_second = loop_second;        // 总秒数减1        total_second--;    }      // 每隔一秒，显示值减1; 渲染倒计时时钟    that.setData({      clock:dateformat(total_second - 1)    });      if (total_second == 0) {        that.setData({          // micro_second: \"\",          clock:\"时间到\"        });        clearTimeout(micro_timer);        return ;      }      if (micro_second_current <= 0) {    micro_second_current = micro_second_init;  }  micro_timer = setTimeout(function(){    that.setData({      micro_second: micro_second_current - 1    });    micro_second_current--;    // 放在最后++，不然时钟停止时还有10毫秒剩余    loop_index ++;    countdown4micro(that);  }  ,10)}如此这般，毫秒与时分秒是分别运行渲染的，再次改造，程序可读性更好。dateformat针对于毫秒操作，而不接受秒为数。同时还省却了计算100次为1s的运算/**  * 需要一个目标日期，初始化时，先得出到当前时间还有剩余多少秒 * 1.将秒数换成格式化输出为XX天XX小时XX分钟XX秒 XX * 2.提供一个时钟，每10ms运行一次，渲染时钟，再总ms数自减10 * 3.剩余的秒次为零时，return，给出tips提示说，已经截止 */// 定义一个总毫秒数，以一分钟为例。TODO，传入一个时间点，转换成总毫秒数var total_micro_second = 2 * 1000;/* 毫秒级倒计时 */function countdown(that) {      // 渲染倒计时时钟      that.setData({          clock:dateformat(total_micro_second)      });      if (total_micro_second <= 0) {          that.setData({              clock:\"已经截止\"          });          // timeout则跳出递归          return ;      }          setTimeout(function(){        // 放在最后--        total_micro_second -= 10;        countdown(that);    }    ,10)}// 时间格式化输出，如3:25:19 86。每10ms都会调用一次function dateformat(micro_second) {      // 秒数      var second = Math.floor(micro_second / 1000);      // 小时位      var hr = Math.floor(second / 3600);      // 分钟位      var min = Math.floor((second - hr * 3600) / 60);      // 秒位    var sec = (second - hr * 3600 - min * 60);// equal to => var sec = second % 60;    // 毫秒位，保留2位    var micro_sec = Math.floor((micro_second % 1000) / 10);    return hr + \":\" + min + \":\" + sec + \" \" + micro_sec;}Page({    data: {        clock: ''    },    onLoad: function() {        countdown(this);    }});经过如上优化，代码量减少一半，运行效率也高了。二：LXStepper组件-商品数量加减：适用于购物车商品数量的加减翻看了个文档，微信没有提供现成的组件，于是写了这个小widget。总体思路：最左边框，最右边框由最后外层的容器的border-left与border-right设定；中间2段由input来设定；左右按钮不设边框，圆角效果由最外面容器来设定，这样刚好实现了一个耳熟能详的stepper样式。布局：1.1 准备一个容器view，设置它的宽为width: 70px;height: 21px;边框颜色为#ccc灰色；圆角3px;1.2 内置3个组件，分别是左text，中input，右text，之所以不用button是因为系统自带的button带了样式，为了遵守设计规范，不去重写button的样式。其中input的默认高度是21px。宽度分别为19px，30px，19px，之所以是19px，是因为容器带了左右边距，共占据了2px。1.3 3个组件都是文字居中，text-align: center实现；垂直居中使用line-height: 21px来实现1.4 3个组件都是向左浮动，由于我们计算好3个组件的宽度绝对值，于是不必设定加号按钮的浮动float: right布局文件代码<!-- Stepper容器 --><view class=\"stepper\">    <!-- 减号 -->    <text>-</text>    <!-- 数值 -->    <input type=\"number\" value=\"{{num}}\" />    <!-- 加号 -->    <text>+</text></view>样式表代码/*stepper容器*/.stepper {    border: 1px solid #ccc;    border-radius: 3px;    width: 70px;    height: 21px;    margin:0 auto;}/*加号与减号*/.stepper text {    width: 19px;    height: 28px;    line-height: 21px;    text-align: center;    float: left;}/*数值*/.stepper input {    float: left;    margin: 0 auto;    width: 30px;    text-align: center;    font-size: 12px;    border-left: 1px solid #ccc;    border-right: 1px solid #ccc;}绑定事件2.1 准备两个按钮样式分别对应普通与禁用状态/*普通样式*/.stepper .normal{    color: black;}/*禁用样式*/.stepper .disabled{    color: #ccc;}还要准备一个data的值对象，用于监测数值与状态的改变：data: {    num: 1,    minusStatus: 'disabled'}2.2 加号与减号事件2.2.1 绑定text事件bindtap，分别是bindMinus，bindPlus。按如下处理：取出data中的num值后作自增与自减，对于自减操作要先判断是否大于1才做自减操作，也就是说已经是1的时候，就不要自减了2.2.2 当num已经为1的时候，我们将减号按钮设置为disabled样式，一旦大于1，又变回normal状态，加减事件均要如此处理，不然到了临界值1的时候，回不到normal状态js代码：bindMinus: function() {    var num = this.data.num;    // 如果只有1件了，就不允许再减了    if (num > 1) {        num --;    }    // 只有大于一件的时候，才能normal状态，否则disable状态    var minusStatus = num <= 1 ? 'disabled' : 'normal';    // 将数值与状态写回    this.setData({        num: num,        minusStatus: minusStatus    });},效果如图，注意减号是灰色的#ccc2.3 文本框输入事件2.3.1 在wxml文件中的\\<input\\>监听值变更事件bindchange=\"bindManual\"。注：bindchange是失去焦点才会调用一次的，而bininput是每当有值有改变会有调用一次，敲打123，则会产生值1，12，123三次，比较适合于输入验证。2.3.2 实现bindManualbindManual: function(e) {    var num = e.detail.value;    // 将数值与状态写回    this.setData({        num: num    });}这个步骤看似多余，实则为了num个数同步，以作为提交到网络数据时是真正的data.num，而不是input手工改写的数值"}
{"title": "IOS开发者试水：微信小程序开发教程-从零开始（3） ", "author": "天下雪", "pub_time": "2016-10-19 13:56", "content": "这篇文章我将讲解列表的网络请求以及网络数据的对接。首先找到我们的index.js文件，然后看看微信小程序的网络请求文档很轻松的就可以找到我们的示例代码：wx.request({\r\n  url: 'test.php',\r\n  data: {\r\n     x: '' ,\r\n     y: ''\r\n  },\r\n  header: {\r\n      'Content-Type': 'application/json'\r\n  },\r\n  success: function(res) {\r\n    console.log(res.data)\r\n  }\r\n})url为我们需要请求的接口data为我们的请求参数header为设置请求的 header , header 中不能设置 Referersuccess收到开发者服务成功返回的回调函数，res = {data: ‘开发者服务器返回的内容’}console.log( res.data )为打印请求下来的数据默认为get请求，在此我们就用默认的请求方式，具体的代码如下：onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    wx.request( {\r\n      url: 'http://sep9.cn/qt5wix',\r\n      data: {},\r\n      header: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function( res ) {\r\n        console.log( res.data )\r\n      }\r\n    })\r\n  }运行一下看看我们的请求是否有数据，结果如下图：可以看出我们的数据请求已经是成功的，是不是非常的简单啊？下面我们再来看看怎么给相应的UI赋值吧。首先在我们网络成功的地方加上以下代码: ``` success: function( res ) { console.log( res.data ) that.setData( {      })\r\n  } ```\r\nthat.setData( { })这个方法主要是用来赋值的然后我们得到的数据为res.data通过打印我们可以看出我们的数据结构和原来写死的数据结构是一样的，但是里面的字段确不一样，因此，我们需要把请求下来的值赋值给我们原来的数据源，然后把原有的数据源的字段改成网络请求下来的字段最终的代码如下： ``` //index.js //获取应用实例 var app = getApp() Page({ data: { newList:[] }, //事件处理函数 bindViewTap: function() { wx.navigateTo({ url: ‘../logs/logs’ }) }, onLoad: function () { console.log(‘onLoad’) var that = this wx.request( { url: ‘http://sep9.cn/qt5wix’, data: {}, header: { ‘Content-Type’: ‘application/json’ }, success: function( res ) { console.log( res.data ) that.setData( { newList: res.data }) } }) }}) ```再把index.wxml中赋值的字段改成服务器返回相应的字段，运行结果如下图：不知道什么原因，我这接口返回的图片url在微信小程序中无法显示，为了让效果更加的接近我们的效果图，在本地给我们的数据源加了些网络上的图片，代码如下：\r\ndata: {\r\n    newList:[{fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://a.hiphotos.baidu.com/image/pic/item/c8ea15ce36d3d539be4d77b83f87e950352ab05c.jpg\"} , \r\n             {fistImg:\"http://h.hiphotos.baidu.com/image/pic/item/8d5494eef01f3a2922e765c99b25bc315c607c8d.jpg\"} ,\r\n             {fistImg:\"http://c.hiphotos.baidu.com/image/pic/item/3b292df5e0fe9925ae23d95736a85edf8db1718d.jpg\"} ,\r\n             {fistImg:\"http://g.hiphotos.baidu.com/image/pic/item/faedab64034f78f099a529f47b310a55b3191c0e.jpg\"} ,\r\n             {fistImg:\"http://g.hiphotos.baidu.com/image/pic/item/bd315c6034a85edf9ba34e244b540923dd54758d.jpg\"} ,\r\n             {fistImg:\"http://f.hiphotos.baidu.com/image/pic/item/00e93901213fb80e0ee553d034d12f2eb9389484.jpg\"} ,\r\n             {fistImg:\"http://img1.imgtn.bdimg.com/it/u=2955244448,132069077&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://image.tianjimedia.com/uploadImages/2014/127/32/VP974HZ0AXL2.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} ,\r\n             {fistImg:\"http://img0.imgtn.bdimg.com/it/u=1640246403,1832676351&fm=21&gp=0.jpg\"} \r\n    ]\r\n  }\r\n\r\n随便弄几张图了，看看效果如何，本来还想做下详情页的，由于接口的详情是H5 ,貌似微信小程序不能直接加载H5，如有知道的朋友也可以给我留言告诉我，本人对于H5也是一窍不通。demo下载"}
{"title": "微信小程序登录态验证流程 ", "author": "天下雪", "pub_time": "2016-10-21 11:42", "content": "点击进入原地址小程序调用wx.login得到code.调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。用户数据的加解密通讯需要依赖会话密钥完成。小程序调用wx.getUserInfo得到rawData, signatrue, encryptData.小程序调用server获取token接口, 传入code, rawData, signature, encryptData.server调用微信提供的jsoncode2session接口获取openid, session_key, 调用失败应给予客户端反馈, 微信侧返回错误则可判断为恶意请求, 可以不返回. 微信文档链接这是一个 HTTP 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。接口地址：\"https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code\"server计算signature, 并与小程序传入的signature比较, 校验signature的合法性, 不匹配则返回signature不匹配的错误. 不匹配的场景可判断为恶意请求, 可以不返回. 微信文档链接通过调用接口（如 wx.getUserInfo）获取敏感数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )将 signature、rawData、以及用户登录态发送给开发者服务器，开发者在数据库中找到该用户对应的 session-key，使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的可信度。使用第4步返回的session_key解密encryptData, 将解得的信息与rawData中信息进行比较, 需要完全匹配, 解得的信息中也包括openid, 也需要与第4步返回的openid匹配. 解密失败或不匹配应该返回客户相应错误. 微信文档链接接口如果涉及敏感数据（如wx.getUserInfo当中的 openid ），接口的明文内容将不包含敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptData )进行对称解密。 解密算法如下：对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。对称解密的目标密文为 Base64_Decode(encryptData),对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节对称解密算法初始向量 iv = aeskey, 同样是16字节rawData格式:{\r\n    \"nickName\": \"Band\",\r\n    \"gender\": 1,\r\n    \"language\": \"zh_CN\",\r\n    \"city\": \"Guangzhou\",\r\n    \"province\": \"Guangdong\",\r\n    \"country\": \"CN\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0\"\r\n}\r\nencryptData解密之后格式:{\r\n    \"openId\": \"OPENID\",\r\n    \"nickName\": \"NICKNAME\",\r\n    \"gender\": 1,\r\n    \"city\": \"CITY\",\r\n    \"province\": \"PROVINCE\",\r\n    \"country\": \"COUNTRY\",\r\n    \"avatarUrl\": \"AVATARURL\",\r\n    \"unionId\": \"UNIONID\"\r\n}\r\n使用session_key作为密钥, 加密至少包括openid, timestamp, random(随机值), version(版本)的内容, 得到token. 加密算法可以参考微信对encryptData的加密算法. server应该缓存session_key, 缓存的过期时间不应该小于token的过期时间. 将openid, token返回给客户端.小程序每次业务请求都必须带上openid和token, server验证token的合法性: token能否被正常解密; 解密后的openid和传入的openid是否一致; 解密后可得到token的生成时间, token是否过期. 全部校验通过即可正常处理业务请求."}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:46", "content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "author": "admin", "pub_time": "2016-10-12 22:49", "content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架 ", "author": "admin", "pub_time": "2016-10-12 23:08", "content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置 ", "author": "admin", "pub_time": "2016-10-12 23:22", "content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发 ", "author": "admin", "pub_time": "2016-10-12 23:26", "content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
{"title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "author": "admin", "pub_time": "2016-10-12 23:31", "content": "整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange 事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id 都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id 都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap 点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = e.currentTarget.id //获取到前面唯一的id；If(key){ //用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove 记录到触摸结束的点，如果 X 轴滑动大于 Y 轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X 轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 copy 首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 checked 设置 Boole 开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"}
{"title": "微信小程序试用报告：前端源码逻辑和工作流 ", "author": "天下雪", "pub_time": "2016-10-13 16:49", "content": "文件基本结构：  　  先看入口app.js，app(obj)注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})  　  我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性  　  onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。  　  var logs = wx.getStorageSync('logs') || []获取本地缓存中的logs属性，如果值为空，那么设置logs=[] 与HTML5中的localStorage作用相似logs.unshift(Date.now()) 当前登录时间添加到数组中  　  wx.setStorageSync('logs', logs) 将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据  　  getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数    var that = this    if(this.globalData.userInfo){//用户信息不为空      typeof cb == \"function\" && cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；    }else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {　　　　　　　　 console.log(res)              that.globalData.userInfo = res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口              typeof cb == \"function\" && cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息            }          })        }      })    }  }   　  globalData对象用来存储全局数据，在其他地方调用  　  然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等、  　  最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。 {  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  }}  　  然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。  　  先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。  　  index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。　　<!--index.wxml--><view class=\"container\">//视图容器  <view  bindtap=\"bindViewTap\" class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js page()设置添加    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>  　  index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // 获取入口文件app的应用实例Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //自定义事件处理函数，点击.userinfo的容易触发此函数  bindViewTap: function() {    wx.navigateTo({//全局对象wx的跳转页面方法      url: '../logs/logs'    })  },  onLoad: function () {//发生页面加载时，自动触发该生命周期函数    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据，页面自动渲染      that.setData({        userInfo:userInfo      })    })  }})  　  index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。  　  再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。  　  logs.wxml文件<!--logs.wxml--><view class=\"container log-list\">  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>    <text class=\"log-item\">{{index + 1}}. {{log}}</text>  </block></view>  　　logs.js 文件//logs.jsvar util = require('../../utils/util.js') //util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({  data: {    logs: []  },  onLoad: function () {    this.setData({      logs: (wx.getStorageSync('logs') || []).map(function (log) {//通过wx.getStorageSync获取本地缓存的logs日志数据        return util.formatTime(new Date(log))//日期格式化      })    })  }})　　logs.json文件{    \"navigationBarTitleText\": \"查看启动日志\"   //当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}　　基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"}
{"title": "微信小程序教程：app配置指南 ", "author": "天下雪", "pub_time": "2016-10-13 17:20", "content": "//app.json页面 {//页面注册，有几个页面都要在pages里面注册\"pages\":[\"pages/index/index\",\"pages/logs/logs\",\"pages/main/main\",\"pages/main1/main1\",\"pages/main2/main2\",\"pages/main3/main3\",],//上导航配置及app背景颜色设置\"window\":{//是否开启下拉刷新\"enablePullDownRefresh\":true,//窗口背景颜色，在上拉刷新，下拉刷新，navigate切换页面时可以看见\"backgroundColor\":\"#eee\",//下拉背景字体、loading 图的样式，仅支持 dark/light,（string形式）\"backgroundTextStyle\":\"light\",//上导航条背景颜色\"navigationBarBackgroundColor\": \"orange\",//上导航标题文字\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" //上导航标题字体颜色，仅支持white和black },//底部导航配置\"tabBar\": {\"color\": \"#a9b7b7\",//导航字体默认颜色\"selectedColor\": \"#eb4f38\",//导航字体选中时颜色\"borderStyle\": \"black\", //上border颜色，仅支持 black/white（string形式）\"backgroundColor\": \"rgba(0,0,0,0.4)\",//底部导航背景色\"list\": [ //导航列表2-5个{\"pagePath\": \"pages/index1/index1\", //每个导航的网页对应的路径\"text\": \"首页\", //标题\"iconPath\": \"images/wechat.png\", //默认小图标路径\"selectedIconPath\": \"images/wechatHL.png\" //选中时的小图标路径},{\"pagePath\": \"pages/index2/index2\",\"text\": \"日记\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},{\"pagePath\": \"pages/index3/index3\",\"text\": \"指南\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},]},//网络请求超时时间\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},//是否开启debug模式\"debug\": true}//说明：根据官方文档，上述color和bg-color类型为HexColor即16进制类型，（指定仅支持 black/white，string形式的除外），但实测rbg,rgba和red这些类型目前也支持，但是建议大家还是按文档要求来设置为16进制类型即: #ffffff 类型；////使用时仅需将文件复制下来，根据需求改动即可；////app.json为标准的json文件，所以不能存在有注释，使用的时候需把注释去掉；   //app.js页面App({//当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onLaunch: function () {//onLaunch时调用API从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},//获取用户登录信息getUserInfo:function(cb){var that = thisif(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfotypeof cb == \"function\" && cb(that.globalData.userInfo)}})}})}},//获取后台数据onshow:function(){wx.request({url: 'test.php',data: {x: 'xxx',y: 'yyy'},header: {'Content-Type': 'application/json'},success: function(res) {console.log(res.data)}})},//设置全局数据//本页面通过this.globalData即可取得数据 globalData:{userInfo:null}//其他页面可以通过getApp()获取到小程序实例 //其他页面可以通过getApp().globalData.xxx获取到全局数据})  //app.wxss页面.common {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}//仅支持:类:.commonID:#common标签：common多个标签：common1,common2 伪类::after伪类::before//不支持层级，如.common > view 或者.common view//引入新的单位rpx:rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。及新的rem:rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。//写在app.wxss里面的样式将被设置为公有的，对于其他页面都是可用的"}
{"title": "微信小程序官方文档里看不到的小Tips ", "author": "天下雪", "pub_time": "2016-10-13 17:26", "content": "1. WXML(HTML)　　1.1 小程序的WXML没有HTML的宽容度?那么高，单标签必需是 /> 结尾的。不然会报错。　　1.2 官方推荐使用的基础标签是块标签，给了作为文本标签，但是使用其他标签比如div也是可以使用的，并且都是inline标签。并且wxml的parser会把标签上的不在白名单上的属性都去掉，class, id, data 这些应该都在白名单内，但是href什么的是不会有的，所以如果你用传统的html的标签构建页面理论上也是可行的，不过这些都是inline标签，需要自行设定display。　　1.3 scroll-view 的scroll-top, scroll-left 是可以修改scroll-view的滚动位置的。但是用户自己滚动了之后小程序并不会去改变 scroll-top, scroll-left 的赋值（并不是双向同步的）。如果这时使用setData去修改的话，scroll-top, scroll-left 的赋值和上一次的值相同，小程序是不会运用这个修改的，所以表现就是设置没有生效。这时只能先设置一个其他值，再设置回去（这里还可以体现setData方法是同步的）。scroll-view 获取scroll位置，只能通过bindscroll的回调函数获取，所以需要取scroll位置的请自行预存好。scroll-view 还是有webview的 scroll 的臭毛病，在居顶位置如果第一个动作是向下滚动的，会导致之后手怎么滑都滚不动，设置scroll-top 不为0，设个1就好了。　　1.4 input 目前只支持文字居左，其他都是不行的（模拟器可以）。如果你做表单，建议把input等表单元素都放在form中，from触发submit时会返回内部所有表单元素的name-value。不然只能绑定所有表单元素的 change 事情来获取，甚是麻烦。　　1.5 只有  checkbox-group 有 change 事件，单个的checkbox是没有的，如果你只有一个checkbox， 觉得外面套一个checkbox-group麻烦又不美观的话，可以用 switch type=\"checkbox\" 代替。　　1.6 map 组建目前直接在app第一个页面加载会出现加载失败。需要在onLoad之后再加在。可以先wx:if=\"false\" 然后onLoad的之后改成 true 就行了。　　1.7 map, canvas 像是在webview上面盖一个native组件的感觉。它们是没法被overflow 以及 上面盖元素的，你可以认为z-index写多高都没法在他上面。所以不建议在页面上做弹层和蒙层。canvas 无法放在scroll-view中滚动会定位在初始位置，如果你给canvas设置背景颜色的话，你会发现背景色块跟着滚了，图没滚。2. WXSS(CSS)　　2.1 WXSS 和 CSS很像，基本所有的CSS都支持，小程序还提供了 rpx 这个单位。一屏幕宽是750rpx。推荐使用这个来作为布局。不过有一些细小的差别我下面会列出　　2.2 WXSS不支持 大括号嵌套（{{}} ）。所以key-frames，CSS animation 就不可用了，不过transition 是可用的。　　2.3 目前测试引入字体也是不可用的，前面WXML中提到的内容看SVG也是没法使用的。所以icon目前只能用图的方式做了。　　2.4 WXSS中是不能引入本地资源的, 只能使用线上资源（模拟器是可以，但是别信），可以使用base64。　　2.5 WXSS的 rule 是不支持集联的。所以不能 body .main {background:#000;} 这么写。所以写起来还是比较费劲的。每个class都得很长，不然怕重名。不过支持 li.current {color: red;} 这样的写法，支持after， before伪类，但是不支持 first-child last-child nth-child 这类伪类。　　2.6 app.wxss 和每个 page 的wxss 的覆盖关系是: 如果有同名 rule 的话，page 会覆盖 app 的，不是merge是覆盖。　　3. JS　　3.1 JS 的运行环境和view的运行环境是隔离的。JS只能通过事件获取时机和setData方法修改数据来改变view。　　3.2 JS 目前有个很大的问题是无法获取到页面px级的宽度高度, 所有事件回调的单位都是px级的而不是rpx的，但是又不知道当前rpx，px的转换关系。比如过你用canvas画图。你都不知道边界在哪里，这个很蛋疼。　　3.3 上面有说过 setData方法如果上一个值和下一个值相同时，是不会触发view修改的（见1.3）　　3.4 使用 navigate 跳转的时候可以使用queryString的方式跟在相对地址上，onLoad事件会在入参中传入（会转化成object），但是 navigate back的时候没有一个官方给出的数据通讯机制。可以使用getApp() 获取到全局对象，给上面加点东西，自行实现。navigate 最多5个什么的就不说了。　　3.5 canvas getActions被调用之后，actions是会被清空的。即连续调用两次getActions，第二次是空数组。　　3.6 开发者工具是nw写的，我就看了看裙底的源码，开发者工具中WXML确实是有parser再拼装的过程的。但是并不能说明小工具是native的，从css的支持力度到webview的一些bug相似度来看，我还是觉得像webview，但是组件比如map，canvas什么的用的是原生view，然后盖在webview上的感觉。但是不管怎么说 auto-focus 能自动呼出键盘就已经是个很大的好评了。"}
{"title": "微信小程序开发准备：必修课程推荐 ", "author": "天下雪", "pub_time": "2016-10-13 18:06", "content": "今天，我们都想学前端！！！1、HTML基础入门带你从最最基础的知识开始，认识 HTML，通过 HTML 文件的结构、常用的标签、元素、属性、样式、超文本等内容让大家对 HTML 有一个完整的认识！2、HTML5基础入门HTML5有很多新特性，这个教程就带你入门了解HTML5的一些新特性。我们知道啊：html是结构 （网页一个架子，显示内容）、css是样式（添加背景图片，边框等来修饰）、js是行为（用户操作，华丽的动画）所以呢，光学HTML肯定是不够滴，还需要学习css和js才行啊。3、CSS速成教程这个教程啊，就是带你入门学习CSS知识的，让你对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。4、Javascript基础这个教程呢，是教你学习 JavaScript 的语法及事件、对象、DOM 等基础知识，可以让网页按照你的想法“动”起来。以上呢，是基础，基础打牢了才能动手开发呀，但是，光有理论基础是不够的，还需要在实际开发“小程序”之前，做一些项目，练练手，把所学到的基础知识加以运用！5、HTML5两步实现拼图游戏这个项目就是教你使用HTML5和css3实现的九宫格拼图游戏。做出来是这样的：6、SCSS（SASS）画小黄人这个项目呢，教你通过 SCSS（SASS）画一个会眨眼睛的小黄人，主要学习 CSS3。画出来是这样的：7、JavaScript实现玫瑰花这个项目呢，主要是教你用JavaScript语言实现一朵漂亮的玫瑰花。实现出来是这样的："}
{"title": "微信小程序用户信息解密 C# ", "author": "qq515373375", "pub_time": "2016-10-13 18:24", "content": "背景有幸参加微信小程序的内测，由于公司之前已经有自己的服务大号，积累转化了大量的会员所以在做小程序时，要实现会员的互通，想到的是 unionid 开发文档wx.login(OBJECT)调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=1474887500719wx.getUserInfo(OBJECT)获取用户信息，需要先调用 wx.login 接口其中需要的unionid在调用成功返回的参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html?t=1474887500618是个加密数据，解密算法参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html 实现code 换取 session_key前端先调 wx.login 得到code后端换取session_key和openid， openid返回前端，session_key保存（缓存）解密用注意：一个code只能换取一次；再次调用 wx.login， 会导致上一次的 session_key 失效，解密出来的都是乱码　　2. 解密前端先调 wx.getUserInfo 得到encryptData用login返回的openid，encryptData 调后端解密刚开始按开发文档，用C# 系统自带AES解密失败报“填充无效，无法被移除”异常在网上扒拉了一圈，也没找到有用的信息，最终在github上，找带了参考代码，自己再改改，才解密成功结语代码本身没啥牛逼的，希望贴出来能对后面的开发伙伴有所帮助 :)"}
{"title": "anjular2和微信小程序的对比 ", "author": "qq515373375", "pub_time": "2016-10-13 18:30", "content": "1条件渲染：小程序：用 wx:if=\"{{condition}}\" 来判断是否需要渲染该代码块。<view wx:if=\"{{condition}}\">　　　　True</view>ng2:  用 *ngIf=\"condition\"来判断是否需要渲染该代码块。<p  *ngIf=\"condition\">　　　　condition is true and ngIf is true.</p>对于ng2, 当=号里面的值为真时才渲染标签内的元素，为假时将元素移除。注意：这里是将元素从DOM树里面完全移除，而不是隐藏。 对于需要频繁切换可见性的元素来说，改变元素的display无疑要比频繁的移除和重新渲染高效的多。 不过，angulra2开发者认为，在大多数 UI中，当我们“关闭”一个组件时，在相当长时间内都不大可能想再见到它——可能永远也不见。 而且，当我们隐藏掉一个元素时，组件的行为还在继续——它仍然附加在它所属的 DOM 元素上， 它也仍在监听事件。 Angular 会继续检查哪些能影响数据绑定的变更。 组件原本要做的那些事情仍在继续。 虽然不可见，组件及其各级子组件仍然占用着资源。  虽然每种方法都有各自的优点和缺点，但使用 ngIf 来移除不需要的组件通常都会比隐藏它们更好一些。微信小程序文档较少，不过根据文档中这段话：一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好可以推测wx:if和*ngIf实质是一样的，虽然在写法上有些区别，wx是将条件包裹在{{ condition }}里面。 2 循环列表渲染小程序：列表渲染：默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item<view wx:for=\"{{items}}\">　　{{index}}: {{item}}</view>如某个数组为[a,b,c,d]，则对应的下标index为0,1,2,3，对应的变量名item为a,b,c,d使用wx:for-item可以指定数组当前元素的变量名；使用wx:for-index可以指定数组当前下标的变量名；如： <view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">　　　　  {{idx}}: {{itemName.message}}      </view>则此时下标idx为0,1,2,3, 变量名itemName为a,b,c,dng2:<div *ngFor=\"let hero of heroes; let i=index\">　　　　{{i + 1}} - {{hero.fullName}}</div>ng2里指定变量名用的是let hero of heroes，即设置变量名为hero，对应微信的 wx:for-item=\"itemName；指定下标let  i=index，对应微信的wx:for-index=\"idx\";上面这种写法实际上已经经过语法糖包装后的写法，原来的写法太啰嗦，形似类似： <template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">　　　　<li>...</li></template> 3数据绑定微信：数据绑定使用 Mustache 语法（双大括号）将变量包起来　　　　<view> {{ message }} </view>并在js文件里面设置对应的变量值Page({　　data: {　　　　message: 'Hello MINA!'　　}})微信小程序没有双向数据绑定，要改变变量值时，需要通过setdata改变，监听事件如eventname: function(e) {　　this.setData({　　　　data: \"im_new\"　　})}注意不能这样this.data=\"im_new\"，否则会出错 ng2:ng2:主要看一下双向数据绑定：<input [(ngModel)]=\"currentHero.firstName\">（123）表示绑定事件，[12345]表示绑定数据通过[( )]即可实现双向数据绑定这是种简写的形式，背后是这样写的<input　　　　[ngModel]=\"currentHero.firstName\"　　　　(ngModelChange)=\"currentHero.firstName=$event\">"}
{"title": "微信小程序的数据访问 ", "author": "qq515373375", "pub_time": "2016-10-13 18:34", "content": "先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js , app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的 数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq to sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const API_URL = 'http://localhost:4424/api/'function getApi(url,params){  return new Promise((res,rej)=>{    wx.request({      url:API_URL+'/'+url,      data:Object.assign({},params),      header:{'Content-Type': 'application/json'},      success:res,      fail:rej    })  })}module.exports = {  GetByParams(url,page=1,pageSize=20,search = ''){    const params = { start: (page - 1) * pageSize, pageSize: pageSize }    return getApi(url, search ? Object.assign(params, { q: search }) : params)      .then(res => res.data)  },  GetById(url,id){    return getApi(url, id)      .then(res => res.data)  }}module.exports = {}是固定写法，里面写一个一个的方法，每个方法用,隔开。我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const req = require('../../utils/util.js')Page({  data: {    imgUrls: [],    indicatorDots: true,    autoplay: true,    interval: 2000,    duration: 2000  },  onLoad(){    req.GetByParams('home/homebanner')//看这里   看这里   看这里    .then(d=>this.setData({imgUrls:d,loading:false}))    .catch(e=>{      this.setData({imgUrls:[],loading:false})    })  }})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了"}
{"title": "微信小程序之预览图片 ", "author": "qq515373375", "pub_time": "2016-10-13 18:36", "content": "选择图片时可设置图片是否是原图，图片来源。这用的也挺常见的，比如个人中心中设置头像，可以与wx.upLoadFile()API使用主要方法：wx.chooseImage(object)wxml<button type=\"primary\" bindtap=\"listenerButtonChooseImage\">点击我选择相册button><image src=\"{{source}}\" mode=\"aspecFill\" style=\"width: 640rpx; height: 640rpx\"/>jsPage({  data:{    // text:\"这是一个页面\"    source: ''  },  /**   * 选择相册或者相机 配合上传图片接口用   */  listenerButtonChooseImage: function() {      var that = this;      wx.chooseImage({          count: 1,          //original原图，compressed压缩图          sizeType: ['original'],          //album来源相册 camera相机           sourceType: ['album', 'camera'],          //成功时会回调          success: function(res) {              //重绘视图              that.setData({                  source: res.tempFilePaths              })          }      })  },wx.previewImage(object)这又是一个奇葩API真实搞不懂怎么用这个。先模仿下官方咋使用但是没有效果，搞懂了在补充下自己的使用wxml<button type=\"primary\" bindtap=\"listenerButtonPreviewImage\">展示图片button>jsvar app = getApp()　　Page({　　　　data: {　　　　　　banner:['../images/big.png', '../images/big.png', '../images/big.png'],　　　　　　modalHidden: true　　　　},　　　　tapMove:function(e){　　　　　　this.setData({ 　　　　　　　　num: e.detail.current+1　　　　　　})　　　　},/**  * 预览图片   */ 　　listenerButtonPreviewImage: function() {   　　　　wx.previewImage({     　　　　　　current: '../images/big.png',        　　　　//这根本就不走       　　　　 success: function(res) {          　　　　console.log(res);       　　　　 },        　　　　//也根本不走       　　　　 fail: function() {          　　　　console.log('fail')       　　　　 },　　　　　　complete:function(){　　　　　　　　console.log('complete')　　　　　　}  　　　　　　 }) 　　　　　　},onLoad: function () { var that = this;that.setData({num:1,count:that.data.banner.length})}})"}
{"title": "微信小程序的快速搭建 ", "author": "qq515373375", "pub_time": "2016-10-13 18:37", "content": "「小程序」这个划时代的产品发布快一周了，互联网技术人都在摩拳擦掌，跃跃欲试。可是小程序目前还在内测，首批只发放了\r\n 200 个内测资格（泪流满面）。本以为没有 AppID \r\n这个月就与小程序无缘了，庆幸的是微信这两天发布了正式版开发者工具，无需内测邀请也可以尝鲜了。\r\n因此也就有了我与「小程序」的初体验，而我的感受只有一个字——爽！\r\n选择哪个「小程序」Demo？\r\n在知名同性交友网站 Github 上，「小程序」的 Demo 不少，但是大多只是简单的 API 演示，有的甚至直接把页面数据写在了 \r\njson 文件里（分明有网络请求 API）。我想体验的是能够将服务端和小程序端无缝连接起来（体验够爽）的项目。最终，我选择了腾讯云官方推出的「小相册」项目。\r\n「小相册」主要实现了以下功能：\r\n\r\n列出对象存储 COS 中的图片列表。\r\n\r\n点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 对象存储 COS 中。\r\n\r\n轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片。\r\n\r\n长按任意图片，可将其保存到本地，或从 对象存储 COS 中删除。\r\n\r\n效果演示图（受开发工具的限制，部分功能尚未实现）\r\n\r\n对象存储服务（Cloud Object Service）是腾讯云推出的面向企业和个人开发者提供的高可用，高稳定，强安全的云端存储服务。可以将任意数量和形式的非结构化数据放入COS，并在其中实现数据的管理和处理。\r\n\r\n之所以选择腾讯云的 Demo，一是因为它是腾讯自家推出的，项目的质量有保障；二是因为它是少有的既讲小程序开发，又介绍云端部署的项目。\r\n稍微有点经验的程序员都知道，架构要动静分离，静态文件最好不要放在自己的服务器上，要放在专门用来存储的对象存储服务器COS上，并且用CDN 加速。「小相册」后端采用的是 Node.js，Nginx作为反向代理。\r\n第一步：搭开发环境\r\n首先，我们需要在本地搭建好微信「小程序」的开发环境。即下载开发者工具。微信官方已经推出了正式版 IDE，大家没有必要再去下载破解版了。打开官网下载页面，根据自己的操作系统选择。我使用的是 Mac 版。\r\n安装好之后打开运行，会要求微信扫码登陆。之后，就可以看到创建项目的页面了。\r\n\r\n选择添加项目，没有 AppID 就选无（如果乱写会报错，到时可能无法进入项目）。如果你选择的项目目录为空，请如图所示勾选在“当前目录中创建quick start项目”。\r\n\r\n点击“添加项目”之后，我们会进入开发工具的调试页面。\r\n第二步：下载「小相册」源码\r\n接下来，我们下载「小相册」的源码。可以选择直接从腾讯云官网提供的链接下载，也可以从腾讯云团队的 Github 仓库拉取。我推荐从 Github 仓库拉取，这样可以及时获取最新的代码。\r\ngit clone https://github.com/CFETeam/weapp-demo-album.git\r\n最终，我们会得到类似这样的文件目录。\r\n\r\n简单解释下目录结构：\r\n\r\napplet（或app）: 「小相册」应用包代码，可直接在微信开发者工具中作为项目打开。\r\n\r\nserver: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI 接口示例，用于拉取图片资源、上传图片、删除图片。\r\n\r\nassets：「小相册」的演示截图。\r\n\r\n源码下载完成之后，我们打开微信 web 开发者工具，新建项目「小相册」，选择目录applet（或app）。\r\n\r\n「小相册」源码分析\r\n在进行部署之前，我们来简单分析一下「小相册」的具体代码。毕竟只看效果不是我们的目的，我们的目的是以「小相册」为例，了解如何开发小程序并与服务端进行交互。「小相册」包含一个描述整体程序的 app 和多个描述各自页面的 page。主程序 app 主要由三个文件组成，分别是 app.js（小程序逻辑）、app.json（小程序公共设置）和 app.wxss（小程序公共样式表），其中前两个为必备文件。config.js 文件中包含了一些部署域名的设置，现在不用管。在 pages 目录下，有两个 page 页面，分别是 index 和 album。页面结构算是比较简单的，其中 index \r\n是小程序启动时默认进入的页面。每个页面下，至少要有 .js（页面逻辑）和 .wxml（页面结构）两个文件，.wxss（页面样式表）和 \r\n.json（页面配置）文件为选填。你可能注意到了，这些文件的文件名与父目录的名称相同。这是微信官方的规定，目的是减少配置项，方便开发者。接下来我们以 index 页面为例做简单的解释。index.wxml 是这个页面的表现层文件，其中的代码非常简单，可以分为上下两大部分。<view>\r\n    <view class=\"page-top\">\r\n        <text class=\"username\">恭喜你</text>\r\n        <text class=\"text-info\">成功地搭建了一个微信小程序</text>\r\n        <view class=\"page-btn-wrap\">\r\n            <button class=\"page-btn\" bindtap=\"gotoAlbum\">进入相册</button>\r\n        </view>\r\n    </view>\r\n    <view class=\"page-bottom\">\r\n        <text class=\"qr-txt\">分享二维码邀请好友结伴一起写小程序！</text>\r\n        <image src=\"../../images/qr.png\" class=\"qr-img\"></image>\r\n        <image src=\"../../images/logo.png\" class=\"page-logo\"></image>\r\n    </view>\r\n</view>\r\n\r\n\r\n\r\n\r\n\r\n页面的演示效果如下：\r\n\r\n我们看到，页面上有一个“进入相册”的按钮。正常理解，点击后该按钮后我们就可以进入相册了（这不废话嘛）。那小程序背后是怎样实现该操作的呢？\r\n在 index.wxml 中，我们发现对应的 button 标签上定义了一个 bindtap 属性，绑定了一个叫做 gotoAlbum 的方法。而这个方法可以在 index.js 文件中找到。事实上，文件中也只定义了这一个方法，执行的具体动作就是跳转到 album 页面。\r\nPage({\r\n    // 前往相册页\r\n    gotoAlbum() {\r\n        wx.navigateTo({ url: '../album/album' });\r\n    },\r\n});\r\nalbum.js 页面中编写了程序的主要逻辑，包括选择或拍摄图片、图片预览、图片下载和图片删除；album.wxml 中三种视图容器 view、scroll-view、swiper均有使用，还提供了消息提示框 toast。具体方法和视图的实现请查看项目源码。所有的这些功能都写在 Page 类中。\r\nlib 目录下提供了小程序会用的一些辅助函数，包括异步访问和对象存储 COS 的 API。\r\n总的来说，和微信官方宣传的一样，在开发者工具下进行小程序的开发，效率确实提高了很多，而且有很多微信提高的组件和 API。所以，在开发速度这点上的体验还是非常爽的。\r\n另外，由于「小相册」需要使用诸多云端能力，如图片的上传和下载，我们还需要进行服务器端的部署和设置。具体请看接下来的步骤。\r\n第三步：云端部署 server 代码\r\n虽然服务端的开发不是本文的重点，但是为了全面地体验「小相册」的整个开发部署流程，我们还是有必要了解服务端的部署，这里我们使用的是腾讯云。\r\n如果你想更爽一点，那么可以选择腾讯云官方提供的小程序云端镜像。「小相册」的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，可以直接使用。可谓是一键部署好云端。\r\n如果你以前没有使用过腾讯云，可以选择免费试用（我已经领取了 8 天的个人版服务器），或者领取礼包以优惠的价格购买所需的服务。\r\n\r\n你也可以选择将「小相册」源码中的server文件夹上传到自己的服务器。\r\n第四步：准备域名和配置证书\r\n如果你已经有腾讯云的服务器和域名，并配置好了 https，那么可以跳过第 4-6 步。\r\n在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求。简单来说，就是你的域名必须走 https 协议。所以你还需要为你的域名申请一个证书。如果没有域名，请先注册一个。由于我们没有收到内测，也就暂时不用登录微信公众平台配置通信域名了。\r\n第五步：Nginx 配置 https\r\n微信小程序云端示例镜像中，已经部署好了 Nginx，但是还需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。\r\n\r\n请将红框部分换成自己的域名和证书，并且将 proxy_pass 设置为 Node.js 监听的端口，我的是 9993。\r\n配置完成后，重新加载配置文件并且重启 Nginx。\r\nsudo service nginx reload\r\nsudo service nginx restart\r\n第六步：域名解析\r\n我们还需要添加域名记录，将域名解析到我们的云服务器上，这样才可以使用域名进行 https 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们的域名就支持 https 访问了。\r\n\r\n\r\n第七步：开通和配置 COS\r\n由于我们希望实现动静分离的架构，所以选择把「小相册」的图片资源是存储在 COS 上的。要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作。\r\n\r\n点击创建 Bucket。会要求选择所属项目，填写相应名称。这里，我们只需要填上自己喜欢的 Bucket 名称即可。\r\n然后在 Bucket 列表中，点击刚刚创建的 Bucket。然后在新页面点击“获取API密钥”。\r\n弹出的页面中包括了我们所需要的三个信息：唯一的 APP ID，一对SecretID和SecretKey（用于调用 COS API）。保管好这些信息，我们在稍后会用到。最后，在新的 Bucket 容器中创建文件夹，命名为photos。这点后面我们也会提到。\r\n第八步：启动「小相册」的服务端\r\n在官方提供的镜像中，小相册示例的 Node 服务代码已部署在目录 /data/release/qcloud-applet-album 下。进入该目录，如果是你自己的服务器，请进入相应的文件夹。\r\ncd /data/release/qcloud-applet-album\r\n在该目录下，有一个名为 config.js 的配置文件（如下所示），按注释修改对应的 COS 配置：\r\nmodule.exports = {\r\n    // Node 监听的端口号\r\n    port: '9993',\r\n    ROUTE_BASE_PATH: '/applet',\r\n\r\n    cosAppId: '填写开通 COS 时分配的 APP ID',\r\n    cosSecretId: '填写密钥 SecretID',\r\n    cosSecretKey: '填写密钥 SecretKey',\r\n    cosFileBucket: '填写创建的公有读私有写的bucket名称',\r\n};\r\n另外，cd ./routes/album/handlers，修改 list.js，将 const listPath 的值修改为你的Bucket 下的图片存储路径。如果是根目录，则修改为 '/'。当前服务端的代码中将该值设置为了 '/photos' ，如果你在第七步中没有创建该目录，则无法调试成功。\r\n小相册示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：\r\npm2 start process.json\r\n第九步：配置「小相册」通信域名\r\n接下来，在微信 web 开发者工具打开「小相册」项目，并把源文件config.js中的通讯域名 host 修改成你自己申请的域名。\r\n\r\n将蓝色框内的内容修改为自己的域名\r\n然后点击调试，即可打开小相册Demo开始体验。\r\n\r\n\r\n最后提示一点，截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。但是由于没有内测资格，我们暂时是没办法体验了。\r\n嗯，就这点不够爽，没有内测邀请。"}
{"title": "秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ... ", "author": "天下雪", "pub_time": "2016-10-21 14:46", "content": "1.下载ThinkPHP 5.0.1：http://www.thinkphp.cn/down/855.html2.安装 解压到站点根目录http://localhost/thinkphp_5.0.1_core/public/访问，可以看到:) ThinkPHP V5 十年磨一剑 - 为API开发设计的高性能框架 [ V5.0 版本由 七牛云 独家赞助发布 ] 新手快速入门完全开发手册说明安装成功。以上url等同于http://localhost/thinkphp_5.0.1_core/public/index.php/index/index/index第一个index是模块名，第二个index是控制器名，第三个index是方法名出处参见config.php Line 60-673.用户登录控制器目标是我们需要一个如下的接口，供我们提交用户信息http://localhost/thinkphp_5.0.1_core/public/index.php/index/user/login参数：openid创建Controller稍加改造输出json格式header(\"Content-type: application/json\");无效！查看文档，需要改配置修改第36行4.用户登录模型5. 配置数据库信息进入database.php6. 建表7. 获取用户输入使用PostMan 测试输出\"灵犀网络\"字样8. 查询是否用户是否已经存在通过openid查询数据库，判断用户是否已经注册如有，返回用户的id,accessToken,username9. 插入新用户创建并返回用户信息10. json输入用户信息，供小程序本地缓存，主要是accessToken配置文件config.php指定了返回类型是json的话，不必通过$user->toArray()，即为纯净的array。而不是如下的对象格式。"}
{"title": "微信小程序开发之吐司toast(消息提示框) ", "author": "天下雪", "pub_time": "2016-10-21 14:50", "content": "做Android的时候对toast是很熟悉的.微信小程序开发中吐司也是重要的消息提示方式.上代码:1.index.wxmltoast是微信提供的组件,duration是延迟时间,单位毫秒.这里设置是1000ms.bindchange是事件.在index.js中触发事件即可。<!--index.wxml-->  <toast hidden=\"{{toastHidden}}\" duration=\"1000\" bindchange=\"onToastChanged\">            {{toastText}}    </toast>  2.index.js先在data中定义参数,toastHidden(吐司是否显示),toastText(吐司文本),函数onToastChanged(),当toastHidden变化为时执行,也就是为false时置为true;不加函数吐司不会消失。//index.js  //获取应用实例  var app = getApp()  Page( {    data: {      toastHidden: true, //吐司      toastText: '',//吐司文本    },    onToastChanged: function() {      this.setData( { toastHidden: !this.data.toastHidden });    },    onLoad: function() {      this.setData( {        toastHidden: false, //吐司        toastText: '我是吐司',//吐司文本      })    }  })  我是直接在页面初始化(onLoad:function)时执行,可根据自己需求赋值给toastHidden和toastText。"}
{"title": "微信小程序把玩《六》：picker组件，radio组件，slider组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:03", "content": "一：picker组件picker选择器分为三种，普通选择器，时间选择器， 日期选择器 用mode属性区分，默认是普通选择器。测试时时间和日期点击无反应不知道是BUG还是啥！没法手机测试现在也不知道咋回事！！主要属性：普通选择器时间选择器日期选择器wxml<view>普通选择器</view><!--mode默认selector range数据源value选择的index bindchange事件监听--><picker mode=\"selector\" range=\"{{array}}\" value=\"{{index}}\" bindchange=\"listenerPickerSelected\">    <text>{{array[index]}}</text></picker><view>时间选择器</view><picker mode=\"time\" value=\"{{time}}\" start=\"06:00\" end=\"24:00\" bindchange=\"listenerTimePickerSelected\">    <text>{{time}}</text></picker><view>日期选择器</view><picker mode=\"date\" value=\"{{date}}\" start=\"2016-09-26\" end=\"2017-10-10\" bindchange=\"listenerDatePickerSelected\">    <text>{{date}}</text></picker>jsPage({  data:{    // text:\"这是一个页面\"    array: ['Android', 'IOS', 'ReactNativ', 'WeChat', 'Web'],    index: 0,    time: '08:30',    date: '2016-09-26'  },  /**   * 监听普通picker选择器   */  listenerPickerSelected: function(e) {      //改变index值，通过setData()方法重绘界面      this.setData({        index: e.detail.value      });  },   /**   * 监听时间picker选择器   */  listenerTimePickerSelected: function(e) {      //调用setData()重新绘制      this.setData({          time: e.detail.value,      });  },  /**   * 监听日期picker选择器   */  listenerDatePickerSelected:function(e) {    this.setDate({      date: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：radio组件赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              新手跳坑指南：小程序开发过程中遇到的各种坑 \n              微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ...\n                                    \n                  • 微信小程序把玩《二》：页面生命周期，模块化，数据绑定，view组件 ... ...\n                                    \n                  • 微信小程序把玩《三》：scroll-view组件，swiper组件，icon组件\n                                    \n                  • 微信小程序把玩《四》：text组件，progress组件，button组件\n                                    \n                  • 微信小程序把玩《五》：checkbox组件，form组件，input组件\n                                    \n                  • 微信小程序把玩《八》：toast组件，loading组件，navigator组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                    \n                  • 小程序 自定义slider组件音频播放实例\n                                    \n                  • 微信小程序radio点选框，再次点击取消\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJMrVoO', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n简易商城小程序全栈开发(mpvue+koa+mongodb2018-07-27初试小刀自我简历小程序2018-08-08微信小程序使用相机2018-07-27「小程序JAVA实战」微信小程序简介（一）2018-08-10「小程序JAVA实战」微信小程序的简要注册流2018-08-10\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1534149077|03fe44caa5e4967f82e92150da650473|2';"}
{"title": "微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:11", "content": "一：switch组件switch开关组件使用主要属性：wxml<!--switch类型开关--><view>switch类型开关</view><switch type=\"switch\" checked=\"true\" bindchange=\"listenerSwitch\"/><!--checkbox类型开关--><view>checkbox类型开关</view><switch type=\"checkbox\" bindchange=\"listenerCheckboxSwitch\" />jsPage({  data:{    // text:\"这是一个页面\"  },  /**   * switch开关监听   */  listenerSwitch: function(e) {    console.log('switch类型开关当前状态-----', e.detail.value);  },  /**   * checkbox类型开关监听   */  listenerCheckboxSwitch: function(e) {    console.log('checkbox类型开关当前状态-----', e.detail.value)  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：action-sheet组件action-sheet组件是从底部弹出可选菜单项，估计也是借鉴iOS的设计添加的，action-sheet有两个子组件， action-sheet-item为每个选项，action-sheet-cancel取消选项，与action-sheet-item中间会有间隔，并且点击会触发action-sheet监听事件主要属性：wxml<!--触发action-sheet事件--><button type=\"primary\" bindtap=\"listenerButton\">弹出ActionSheet</button><!--默认action-sheet为隐藏，由button触发--><action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"listenerActionSheet\" >    <block wx:for-items=\"{{actionSheetItems}}\" >         <action-sheet-item >{{item}}</action-sheet-item>    </block>    <!--自动隐藏action-sheet-->    <action-sheet-cancel>取消</action-sheet-cancel></action-sheet>jsPage({  data:{    // text:\"这是一个页面\"    actionSheetHidden: true,    actionSheetItems: ['item1', 'item2', 'item3']  },  listenerButton: function() {      this.setData({        //取反          actionSheetHidden: !this.data.actionSheetHidden      });  },  listenerActionSheet:function() {    this.setData({      actionSheetHidden: !this.data.actionSheetHidden    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})三：modal组件modal弹出框常用在提示一些信息比如：退出应用，清楚缓存，修改资料提交时一些提示等等。常用属性：wxml<!--监听button点击事件--><button bindtap=\"listenerButton\" type=\"primary\">弹出modal</button><!--弹出框--><modal     title=\"退出应用\"     hidden=\"{{hiddenModal}}\"     confirm-text=\"再看看\"     cancel-text=\"退出\"     bindconfirm=\"listenerConfirm\"     bindcancel=\"listenerCancel\" >     您是否真的要退出应用     </modal>jsPage({  data:{    // text:\"这是一个页面\"    hiddenModal: true  },  listenerButton:function() {      this.setData({          hiddenModal: !this.data.hiddenModal      })  },  listenerConfirm:function() {      this.setData({          hiddenModal: true      })  },  listenerCancel:function() {      this.setData({          hiddenModal: true      })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})"}
{"title": "精品教程：微信小程序实战之知乎日报 ", "author": "天下雪", "pub_time": "2016-10-21 16:27", "content": "上一次的《微信小程序之小豆瓣图书》制作了一个图书的查询功能，只是简单地应用到了网络请求，其他大多数小程序应有的知识。而本次的示例是知乎日报，功能点比较多，页面也比上次复杂了许多。在我编写这个DEMO之前，网上已经有很多网友弄出了相同的DEMO，也是非常不错的，毕竟这个案例很经典，有比较完整的API，很值得模仿学习。本次个人的DEMO也算是一次小小的练习吧。由于知乎日报是一个资讯类的App，UI的布局主要是以资讯列表页、资讯详情页和评论页为主，当然本次也附带了应用设置页，不过现阶段功能尚未编写，过段时间会更新补充，继续完善。API分析本次应用使用了知乎日报的API，相比上次豆瓣图书的数量比较多了，但是部分仍然有限制，而且自己没有找到评论接口的分页参数，所以评论这块没有做数据的分页。以下是使用到的具体API，更加详细参数和返回结构可参照网上网友分享的 知乎日报-API-分析 ，在此就不做再次分析了。启动界面图片http://news-at.zhihu.com/api/4/start-image/{size}参数说明size图片尺寸，格式：宽*高。例如: 768*1024获取刚进入应用时的显示封面，可以根据传递的尺寸参数来获取适配用户屏幕的封面。获取最新日报http://news-at.zhihu.com/api/4/news/latest返回的数据用于日报的首页列表，首页的结构有上下部分，上部分是图片滑动模块，用于展示热门日报，下部分是首页日报列表，以上接口返回的数据有热门日报和首页日报获取日报详细http://news-at.zhihu.com/api/4/news/{id}参数说明id日报id在点击日报列表也的日报项时，需要跳转到日报详情页展示日报的具体信息，这个接口用来获取日报的展示封面和具体内容。历史日报http://news.at.zhihu.com/api/4/news/before/{date}参数说明date年月日格式时间yyyyMMdd,例如：20150903、20161202这个接口也是用与首页列表的日报展示，但是不同的是此接口需要传一个日期参数，如20150804格式。获取最新日报接口只能获取当天的日报列表，如果需要获取前天或者更久之前的日报，则需要这个接口单独获取。日报额外信息http://news-at.zhihu.com/api/4/story-extra/{id}参数说明id日报id在日报详情页面中，不仅要展示日报的内容，好需要额外获取此日报的评论数目和推荐人数等额外信息。日报长评http://news-at.zhihu.com/api/4/story/{id}/long-comments参数说明id日报id日报的评论页面展示长评用到的接口（没有找到分页参数，分页没有做）日报短评http://news-at.zhihu.com/api/4/story/{id}/short-comments参数说明id日报id日报的评论页面展示段评用到的接口（没有找到分页参数，分页没有做）主题日报栏目列表http://news-at.zhihu.com/api/4/themes主页的侧边栏显示有主题日报的列表，需要通过这个接口获取主题日报栏目列表主题日报具体内容列表http://news-at.zhihu.com/api/4/theme/{themeId}参数说明themeId主题日报栏目id在主页侧栏点击主题日报进入主题日报的内容页，需要展示此主题日报下的日报列表。代码编写启动页作为一个仿制知乎日报的伪APP，高大上的启动封面是必须的，哈哈。启动页面很简单，请求一个应用启动封面接口，获取封面路径和版权信息。当进入页面，在onLoad事件中获取屏幕的宽和高来请求适合尺寸的图片，在onReady中请求加载图片，在请求成果之后，延迟2s进入首页，防止页面一闪而过。onLoad: function( options ) {\r\n    var _this = this;\r\n    wx.getSystemInfo( {\r\n      success: function( res ) {\r\n        _this.setData( {\r\n          screenHeight: res.windowHeight,\r\n          screenWidth: res.windowWidth,\r\n        });\r\n      }\r\n    });\r\n},\r\n\r\nonReady: function() {\r\n    var _this = this;\r\n    var size = this.data.screenWidth + '*' + this.data.screenHeight;\r\n    requests.getSplashCover( size, ( data ) => {\r\n      _this.setData( { splash: data });\r\n    }, null, () => {\r\n      toIndexPage.call(_this);\r\n    });\r\n}\r\n  \r\n/**\r\n * 跳转到首页\r\n */\r\nfunction toIndexPage() {\r\n  setTimeout( function() {\r\n    wx.redirectTo( {\r\n      url: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发之吐司toast(消息提示框) \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程《二》：微信小程序实战之小豆瓣图书\n                                    \n                  • Rebecca Han：微信小程序仿知乎Demo实战教程（适用1028版本）\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 从零开始一个微信小程序版知乎\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJMrVoO', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n微信小程序：一个json帮你完成分享朋友圈图2018-07-16小程序开发技巧总结2018-07-20基于后端云微信小程序开发2018-07-25【微信小程序】性能优化2018-07-17微信小程序仿APP section header 悬停效果2018-07-20手把手教你搭建小程序音视频2018-07-19喂，快给我打一个小程序预览码2018-07-17微信小程序Java登录流程（ssm实现具体功能2018-07-19精确计算微信小程序scrollview高度，全机型2018-07-19\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\nwordpress开源微信小程序2018-08-13获取运动数据2018-08-10一个简洁的音乐、图文微信小程序【小独Lite2018-08-08一个后端撸了一个小程序，表情包小程序2018-08-06求大神帮忙写下这个2018-08-05微信小程序demo：rss阅读器，含注释级源码2018-08-05微信小程序Demo：今日幸运签2018-07-25微信小程序Demo：2life-双生微信小程序2018-07-25手持弹幕来袭2018-07-25\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1534149079|879e28bc12abf5d5bfa6baab6260bf39|2';"}
{"title": "精品教程《二》：微信小程序实战之小豆瓣图书 ", "author": "天下雪", "pub_time": "2016-10-21 16:35", "content": "最近微信小程序被炒得很火热，本人也抱着试一试的态度下载了微信web开发者工具，开发工具比较简洁，功能相对比较少，个性化设置也没有。了解完开发工具之后，顺便看了一下小程序的官方开发文档，大概了解了小程序的开发流程和一些常用的API。了解了小程序之后，自己就有了想要做一个小demo的冲动，虽然自己对小程序还没有做过很多实践，只是在官方例子上徘徊，但是还是想做出点小东西。既然要做一个demo，自然需要到数据，自己有又不想独自搭建服务端，所以在网上搜索可以用来提供测试数据的免费api，最后我选择了豆瓣图书。豆瓣图书提供的api功能比较少，加上不开放appkey申请，所以无法操作用户数据。只能做点简单的图书查询和图书详细信息展示，这个demo只有两个页面，非常之简单。豆瓣图书APIdemo中用到的豆瓣图书api只有两个，一个是图书搜索，另一个是获取图书详情。搜索图书赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程：微信小程序实战之知乎日报 \n              有渔微信小程序系统进阶《四》小程序组件 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程：微信小程序实战之知乎日报\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 小程序之豆瓣电影源码解读\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJMrVoO', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n微信小程序：一个json帮你完成分享朋友圈图2018-07-16小程序开发技巧总结2018-07-20基于后端云微信小程序开发2018-07-25【微信小程序】性能优化2018-07-17微信小程序仿APP section header 悬停效果2018-07-20手把手教你搭建小程序音视频2018-07-19喂，快给我打一个小程序预览码2018-07-17微信小程序Java登录流程（ssm实现具体功能2018-07-19精确计算微信小程序scrollview高度，全机型2018-07-19\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\nwordpress开源微信小程序2018-08-13获取运动数据2018-08-10一个简洁的音乐、图文微信小程序【小独Lite2018-08-08一个后端撸了一个小程序，表情包小程序2018-08-06求大神帮忙写下这个2018-08-05微信小程序demo：rss阅读器，含注释级源码2018-08-05微信小程序Demo：今日幸运签2018-07-25微信小程序Demo：2life-双生微信小程序2018-07-25手持弹幕来袭2018-07-25\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1534149080|67b2b9df86824467eb26843004bdb5d0|2';"}
{"title": "微信小程序入门系列《四》：触控事件 ", "author": "天下雪", "pub_time": "2016-10-22 13:54", "content": "作者：疯狂的猫原文地址：http://www.cnblogs.com/nosqlcoco/p/5954453.html》》》什么是事件事件是视图层到逻辑层的通讯方式。事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如id, dataset, touches。》》》事件分类touchstart 手指触摸touchmove 手指触摸后移动touchcancel 手指触摸动作被打断，如弹窗和来电提醒touchend 手指触摸动作结束tap 手指触摸后离开longtap 手指触摸后后，超过350ms离开》》》事件绑定事件绑定的写法同组件的属性，以 key、value 的形式。key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstartvalue 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。上面简单介绍了小程序事件基础，是时候彰显\"事件\"的威力：单击(tap)双击(dbtap)长按(longtap)滑动多点触控1.单击单击事件由touchstart、touchend组成,touchend后触发tap事件。<view>  <button type=\"primary\" bindtouchstart=\"mytouchstart\" bindtouchend=\"mytouchend\" bindtap=\"mytap\">点我吧</button></view>mytouchstart: function(e){    console.log(e.timeStamp + '- touch start')},mytouchend: function(e){        console.log(e.timeStamp + '- touch end')},mytap: function(e){        console.log(e.timeStamp + '- tap')}2.双击双击事件由两个单击事件组成，两次间隔时间小于300ms认为是双击；微信官方文档没有双击事件，需要开发者自己定义处理。<view>  <button type=\"primary\" bindtap=\"mytap\">点我吧</button></view> 3.长按长按事件手指触摸后，超过350ms再离开。<view>  <button type=\"primary\" bindtouchstart=\"mytouchstart\" bindlongtap=\"mylongtap\"     bindtouchend=\"mytouchend\" bindtap=\"mytap\">点我吧</button></view>mytouchstart: function(e){        console.log(e.timeStamp + '- touch start')},//长按事件mylongtap: function(e){        console.log(e.timeStamp + '- long tap')},mytouchend: function(e){        console.log(e.timeStamp + '- touch end')},mytap: function(e){        console.log(e.timeStamp + '- tap')}单击、双击、长按属于点触事件，会触发touchstart、touchend、tap事件，touchcancel事件只能在真机模拟，不多说了。事件触发顺序单击touchstart → touchend → tap双击touchstart → touchend → tap → touchstart → touchend → tap长按touchstart → longtap → touchend → tap4.滑动手指触摸屏幕并移动，为了简化起见，下面以水平滑动和垂直滑动为例。 滑动事件由touchstart、touchmove、touchend组成坐标图： 以屏幕左上角为原点建立直角坐标系。第四象限为手机屏幕，Y轴越往下坐标值越大（注意跟数学象限的区别）。假设A点为touchstart事件触摸点，坐标为A(ax,ay)，然后手指向上滑动到点B(bx,by)，就满足条件by < ay;同理，向右滑动到C(cx,cy),满足cx > ax；向下滑动到D(dx,dy),满足dy > ay；向左移动到E(ex，ey)满足ex < ax.计算线段AB在Y轴上投影长度为m,在X轴上的投影长度为n计算r = m/n,如果r > 1,视为向上滑动。同理计算线段AC,AD,AE在Y轴投影长度与X轴的投影长度之比，得出向右向下向左的滑动。以上没考虑r为1的情况。<view>  <button type=\"primary\"  bindtouchstart=\"mytouchstart\" bindtouchmove=\"mytouchmove\">点我吧</button></view>5.多点触控由于模拟器尚不支持多点触控，内测开放后，继续补充。"}
{"title": "微信小程序官方设计指南 ", "author": "天下雪", "pub_time": "2016-10-22 16:24", "content": "概要基于微信小程序轻快的特点，我们拟定了小程序界面设计指南和建议。 设计指南建立在充分尊重用户知情权与操作权的基础之上。旨在微信生态体系内，建立友好、高效、一致的用户体验，同时最大程度适应和支持不同需求，实现用户与小程序服务方的共赢。友好礼貌为了避免用户在微信中使用小程序服务时，注意力被周围复杂环境干扰，小程序在设计时应该注意减少无关的设计元素对用户目标的干扰，礼貌地向用户展示程序提供的服务，友好地引导用户进行操作。重点突出每个页面都应有明确的重点，以便于用户每进入一个新页面的时候都能快速地理解页面内容，在确定了重点的前提下，应尽量避免页面上出现其他干扰项影响用户的决策和操作。反例示意此页面的主题是查询，却添加了诸多与查询不相关的业务入口，与用户的预期不符，易造成用户的迷失。纠正示意去掉任何与用户目标不相关的内容，明确页面主题，在技术和页面控件允许的前提下提供有助于用户目标的帮助内容，比如最近搜索词，常用搜索词等。反例示意操作没有主次，让用户无从选择纠正示意首先要避免并列过多操作让用户选择，在不得不并列多个操作时，需区分操作主次，减轻用户的选择难度。流程明确为了让用户顺畅地使用页面，在用户进行某一个操作流程时，应避免出现用户目标流程之外的内容而打断用户。反例示意用户本打算进行搜索，在进入页面时却被突如其来的抽奖弹窗所打断；对于抽奖没有兴趣的用户是非常不友好的干扰； 而即便有部分用户确实被“诱人”的抽奖活动所吸引，离开主流程去抽奖之后可能就遗忘了原本的目标，进而失去了对产品真正价值的利用和认识。清晰明确一旦用户进入我们的小程序页面，我们就有责任和义务清晰明确地告知用户身在何处、又可以往何处去，确保用户在页面中游刃有余地穿梭而不迷路，这样才能为用户提供安全的愉悦的使用体验。导航明确，来去自如导航是确保用户在网页中浏览跳转时不迷路的最关键因素。导航需要告诉用户，我在哪，我可以去哪，如何回去等问题。首先在微信系统内的所有小程序的全部页面，均会自带微信提供的导航栏，统一解决我在哪，如何回去的问题。在微信层级导航保持体验一致，有助于用户在微信内形成统一的体验和交互认知，无需在各小程序和微信切换中新增学习成本或改变使用习惯。微信导航栏微信导航栏，直接继承于客户端，除导航栏颜色之外，开发者无需亦不可对其中的内容进行自定义。但开发者需要规定小程序各个页面的跳转关系，让导航系统能够以合理的方式工作。微信导航栏分为导航区域、标题区域以及操作区域。其中导航区控制程序页面进程。目前导航栏分深浅两种基本配色。导航区（iOS）导航区通常只有一个操作，即返回上一级界面。导航区（Android）同iOS一样，导航区也只有一个返回上一级页面的操作，而点击安卓手机自带的硬件返回键也起到相同作用。微信导航栏自定义颜色规则（iOS和Android）小程序导航栏支持基本的背景颜色自定义功能，选择的颜色需要在满足可用性前提下，和谐搭配微信提供的两套主导航栏图标。建议参考以下选色效果：选色方案示例页面内导航开发者可根据自身功能设计需要在页面内添加自有导航。并保持不同页面间导航一致。但是受限于手机屏幕尺寸的限制，小程序页面的导航应尽量简单，若仅为一般线性浏览的页面建议仅使用微信导航栏即可。开发者可选择小程序页面添加标签分页（Tab）导航。标签分页栏可固定在页面顶部或者底部，便于用户在不同的分页间做切换。标签数量不得少于2个，最多不得超过5个，为确保点击区域，建议标签数量不超过4项。一个页面也不应出现一组以上的标签分页栏。其中小程序首页可选择微信提供的原生底部标签分页样式，该样式仅供小程序首页使用。开发时可自定义图标样式、标签文案以及文案颜色等，具体设置项可参考开发文档。 顶部标签分页栏颜色可自定义。在自定义颜色选择中，务必注意保持分页栏标签的可用性、可视性和可操作性。 减少等待，反馈及时页面的过长时间的等待会引起用户的不良情绪，使用微信小程序项目提供的技术已能很大程度缩短等待时间。即便如此，当不可避免的出现了加载和等待的时候，需要予以及时的反馈以舒缓用户等待的不良情绪。启动页加载小程序启动页是小程序在微信内容一定程度上展现品牌特征的页面之一。本页面将突出展示小程序品牌特征和加载状态。启动页除品牌标志（Logo）展示外，页面上的其他所有元素如加载进度指示，均由微信统一提供且不能更改，无需开发者开发。页面下拉刷新加载在微信小程序内，微信提供标准的页面下拉刷新加载能力和样式。开发者可自定义需要通过下拉交互完成刷新的页面，此类交互微信将提供标准能力和样式。在样式上，刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标识与刷新图标的和谐统一。当用户在该类页面做出下拉交互时，出现微信小程序页面标准加载动画。开发者无需自行开发样式深浅两套下拉样式微信下拉提示用于给用户明确的小程序归属者，防止造假与作弊。此处标示提供深浅两套方案，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。iOS和Android配色方案相同如下展示。微信下拉标示错误使用案例请避免以下错误使用情况，确保信息的可见性和页面的可用性页面内加载反馈开发者可在小程序里自定义页面内容的加载样式。建议不管是使用在局部还是全体，自定义加载样式都应该尽可能简洁，并使用简单动画告知用户加载过程。 开发者也可以使用微信提供的，统一的页面加载样式，如图中例所示。模态加载模态的加载样式将覆盖整个页面的，由于无法明确告知具体加载的位置或内容将可能引起用户的焦虑感，因此应谨慎使用。除了在某些全局性操作下不要使用模态的菊花。局部加载反馈即只在触发加载的页面局部进行反馈，这样的反馈机制更加有针对性，页面改动小，是微信推荐的反馈方式。例如：加载反馈注意事项若载入时间较长,应提供取消操作,并使用进度条显示载入的进度。载入过程中,应保持动画效果 ; 无动画效果的加载很容易让人产生该界面已经卡死的错觉。不要在同一个页面同时使用超过1个加载动画。结果反馈除了在用户等待的过程中需予以及时反馈外，对操作的结果也需要予以明确反馈。根据实际情况，可选择不同的结果反馈样式。对于页面局部的操作，可在操作区域予以直接反馈，对于页面级操作结果，可使用弹出式提示（Toast）、模态对话框或结果页面展示。页面局部操作结果反馈对于页面局部的操作，可在操作区域予以直接反馈，例如点击多选控件前后如下图。对于常用控件，微信设计中心将提供控件库，其中的控件将提供完整操作反馈。页面全局操作结果——弹出式提示（Toast）弹出式提示（Toast）适用于轻量级的成功提示，1.5秒后自动消失，并不打断流程，对用户影响较小，适用于不需要强调成功状态的操作提醒。特别注意该形式不适用于错误提醒。页面全局操作结果——模态对话框对于需要用户明确知晓的操作结果状态可通过模态对话框来提示，并可附带下一步操作指引。页面全局操作结果—结果页对于操作结果已经是当前流程的终结的情况，可使用操作结果页来反馈。这种方式最为强烈和明确的告知用户操作已经完成，并可根据实际情况给出下一步操作的指引。异常可控，有路可退在设计任何的任务和流程时，异常状态和流程往往容易被忽略，而这些异常场景往往是用户最为沮丧和需要帮助的时候，因此需要格外注意异常状态的设计，在出现异常时予以用户必要的状态提示，并告知解决方案，使其有路可退。要杜绝异常状态下，用户莫名其妙又无处可去，卡在某一个页面的情况。2.2中所提到的弹窗和结果页面都可作为异常状态的提醒方式。除此之外，在表单页面中尤其是表单项较多的页面中，还应明确指出出错项目，以便用户修改。异常状态——表单出错表单报错，在表单顶部告知错误原因，并标识出错误字段提示用户修改便捷优雅从PC时代的物理键盘鼠标到移动端时代手指，虽然输入设备极大精简，但是手指操作的准确性却大大不如键盘鼠标精确。为了适应这个变化，需要开发者在设计过程中充分利用手机特性，让用户便捷优雅的操控界面。减少输入由于手机键盘区域小且密集，输入困难的同时还易引起输入错误，因此在设计小程序页面时因尽量减少用户输入，利用现有接口或其他一些易于操作的选择控件来改善用户输入的体验。减少输入，巧用接口例如下图中，在添加银行卡时，采用摄像头识别接口来帮助用户输入。除此之外微信团队还对外开放例如地理位置接口等多种微信小程序接口 ，充分利用这些接口将大大提高用户输入的效率和准确性，进而优化体验。除了利用接口外，在不得不让用户进行手动输入时，应尽量让用户做选择而不是键盘输入。一方面，回忆易于记忆，让用户在有限的选项中做选择通常来说是容易于完全靠记忆输入；另一方面，仍然是考虑到手机键盘密集的单键输入极易造成输入错误。 例如图中，在用户搜索时提供搜索历史快捷选项将帮助用户快速进行搜索，而减少或避免不必要是键盘输入。避免误操作因为在手机上我们通过手指触摸屏幕来操控界面，手指的点击精确度远不如鼠标，因此在设计页面上需点击的控件时，需要充分考虑到其热区面积，避免由于可点击区域过小或过于密集而造成误操作。当简单的将原本在电脑屏幕上使用的界面不做任何适配直接移植到手机上时，往往就容易出现这样的问题。由于手机屏幕分辨率各不相同，因此最适宜点击像素尺寸也不完全一致，但换算成物理尺寸后大致是在7mm-9mm之间。在微信提供的标准组件库中，各种控件元素均已考虑到了页面点击效果以及不同屏幕的适配，因此再次推荐使用或模仿标准控件尺寸进行设计。利用接口提升性能微信设计中心已推出了一套网页标准控件库，包括sketch设计控件库和Photoshop设计控件库，后续还将完善小程序组件，这些控件都已充分考虑了移动端页面的特点，能够保证其在移动端页面上的可用性和操作性能；同时微信开发团队也在不断完善和扩充微信小程序接口，并提供微信公共库，利用这些资源不但能够为用户提供更加快捷的服务，而且对页面性能的提高有极大作用，无形之中提升了用户体验。统一稳定除了以上所提到的种种原则，建议接入微信的小程序还应该时刻注意不同页面间的统一性和延续性，在不同的页面尽量使用一致的控件和交互方式。统一的页面体验和有延续性的界面元素都将帮助用最少的学习成本达成使用目标，减轻页面跳动所造成的不适感。正因如此，小程序可根据需要使用微信提供的标准控件，以达到统一稳定的目的。视觉规范为方便设计师进行设计，微信提供一套可供Web设计和小程序使用的基础控件库；同时提供方便开发者调用的资源。字体规范微信内字体的使用与所运行的系统字体保持一致，常用字号为20, 18, 17, 16,14 13, 11(pt)，使用场景具体如下：字体颜色主内容 Black 黑色，次要内容 Grey 灰色；时间戳与表单缺省值 Light 灰色；大段的说明内容而且属于主要内容用 Semi 黑；蓝色为链接用色，绿色为完成字样色，红色为出错用色 Press与 Disable状态分别降低透明度为20%与10%；列表视觉规范表单输入视觉规范按钮使用原则列表外按钮上文字标准按钮高度为44px下使用: 颜色 ＃000000 / ＃353535 字号 18pt可点状态下文字调整透明度为60%不可点状态下文字调整透明度为30%列表外按钮上文字标准按钮高度为25px下使用: 颜色 ＃000000 / ＃353535 字号 14pt页面线性按钮上文字标准按钮高度为35px下使用: 颜色 ＃09BB07 / ＃353535 字号 16pt图标使用原则"}
{"title": "微信小程序的原型设计尝鲜 ", "author": "天下雪", "pub_time": "2016-10-23 11:47", "content": "\"小程序”来了，大世界要变了？微信小程序可能是近期业绩最火的话题之一了。这个根植于微信流量巨无霸的应用，将对应用市场、对微商、电商、对企业的开发成本、获客成本将产生深远影响？将制造出绕开Google Play和AppStore的另一大App体系？将实现“知人性”的PM张小龙先生的“用后即走”的轻量App之梦？将秒杀传统的App？虽有海量追捧者趋之若鹜，但也有冷静人士淡定的白眼。但无论如何，腾讯这步棋子既然落在了棋盘上，绝不能悔棋，更不可能半途而废，你我这样神经敏感的PM、UX，不尝鲜是不可能的。说动就动，查找到微信小程序的设计规范后，让我们开始吧。造大梦的事儿还是让大佬们去干吧，咱们干点实在的。干活儿首先得挑个工具，我这里使用了Mockplus，近期国内的一款比较流行的原型设计。比较顺手，线框、交互都能胜任。首先尝试做WeUI的界面元素吧。经过一会儿的折腾，搞成了一套（好在WeUI的界面元素比不是太多）。有了这个，之后就方便了。在提示和上传页面中，我使用了交互，点击“成功提示”按钮，弹出提示。点击“上传”按钮，完成进度条的走动。操作很简单：在Mockplus中选中按钮，直接拖拽到准备弹出的提示框上，设置“显示/隐藏”，并在消失时做了延迟处理。提示框的默认显示状态，设为“不可见”。至于进度条的走动，是设置每个进度轨道的“调整尺寸”的交互（设置宽度变化），多拖拽几次鼠标，设置链接就好了，如图：好了，让我们来看看效果。点这里看我的成果：http://run.mockplus.cn/Tnr9w9TyUKjXeDeR/index.html这个尝试到此暂时结束，页面不多，算是个半成品。但在制作时，我边做边琢磨微信在设计中的一些理念：简约、准确、易用。这个伟大的产品之所以在国内能够深入人心，还是有些道理的。"}
{"title": "微信小程序开发框架MINA分析 ", "author": "天下雪", "pub_time": "2016-10-23 11:58", "content": "MINA是微信开发小程序的框架：MINA的目标是通过尽可能简单，高效的方式让开发者可以在微信中开发具有原生APP体验的服务。运行MINA的项目必须要有微信web开发者工具MINA框架中有四种类型的文件:.js文件 基于JavaScript的逻辑层框架.wxml 视图层文件，是MINA设计的一套标签语言.wxss 样式文件，用于描述WXML的组件样式.json 文件，配置文件，用于单个页面的配置和整个项目的配置目录结构为了减少配置项，小程序中一个页面中的四个文件必须要有相同的路径和文件名,使用微信web开发者工具新建一个项目,可以看到他的目录结构是这样的：其中app.js是程序的入口，app.json是项目的配置文件,app.wxss是全局配置的样式文件,logs和index文件夹是是单个页面的文件，utils用来存放常用的工具类文件夹。app.jsapp.js使用App()函数注册一个小程序，可以指定小程序的生命周期小程序的App()生命周期中三个事件可以监听:onLaunch，onShow，onHide。onLaunch：小程序加载完成之后调用,全局只触发一次onShow： 小程序启动，或者从后台到前台会触发一次onHide：小程序从前台到后台会触发一次例如:App({ \r\n onLaunch: function () { \r\n    console.log('App Launch')\r\n  }, \r\n onShow: function () {\r\n    console.log('App Show')  \r\n},  \r\nonHide: function () {\r\n    console.log('App Hide')  \r\n}, \r\n globalData: {\r\n    hasLogin: false  \r\n}\r\n})其中app.js的globalData可以设置全局的变量,在一个页面中可以通过getApp()函数获取小程序的实例，使用App的getCurrentPage()可以获取到当前页面的实例。app.jsonapp.json是小程序的全局配置包括:页面的路径，窗口表现，设置网络超时,开发模式等...页面配置pages:设置页面的路径  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ]配置的index和logs两个页面的路径,在这里使用相对路径配置页面路径。窗口配置windows：用来配置状态栏的颜色，导航条的样式和颜色，标题，已经窗口的背景色:\"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#ffffff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\":\"black\"\r\n  }使用的Color为十六进制的颜色值,比如\"#ffffff\"注意:其中navigationBarTextStyle，导航栏的颜色仅支持black/white。而backgroundTextStyle，下拉背景的样式仅支持dark/light。tabBar: 设置tab应用，tabBar是一个数组，最少需要配置2个，最多能配置5个tab，tab按照数据的顺序排序：\"tabBar\":{\r\n    \"color\":\"#dddddd\",\r\n    \"selectdColor\":\"#3cc51f\",\r\n    \"borderStyle\":\"black\",\r\n    \"backgroundColor\":\"#ffffff\"\r\n  ,\"list\":[\r\n    {\r\n      \"pagePath\":\"pages/index/index\",\r\n      \"iconPath\":\"image/wechat.png\",\r\n      \"selectedIconPath\":\"image/wechatHL.png\",\r\n      \"text\":\"主页\"\r\n      },{\r\n    \"pagePath\":\"pages/logs/logs\",\r\n    \"iconPath\":\"image/wechat.png\",\r\n    \"selectedIconPath\":\"image/wechatHL.png\",\r\n    \"text\":\"日志\"\r\n  }]\r\n}这里设置了两个tab页:index和log，效果如下:networkTimeout设置网络请求的超时时间,小程序有四种类型的网络请求wx.request普通的http请求，配置为requestwx.connect stock链接,配置为connectSocketwx.uploadFile上传文件,配置为uploadFilewx.downloadFile下载文件,配置为downloadFile配置单位为毫秒,例如：\"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"connectSocket\": 10000,\r\n    \"uploadFile\": 10000,\r\n    \"downloadFile\": 10000\r\n  }debug:开发工具中开启debug模式，在控制台面板上可以看到调试信息,我们也可以使用console.log('onLoad')输入log帮助我们调试程序。\"debug\": trueapp.wxssapp.wxss中定义的的样式为全局样式，作用在每一个页面，在page中定义的.wxss文件为局部样式，只作用在局部，局部样式中的定义会覆盖app.wxss中定义的样式。样式的定义:.container {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 200rpx 0;\r\n  box-sizing: border-box;\r\n}其中200rpx中的rpx是reponslve pixel，可以根据屏幕的宽度进行自适应，在iPhone6上1rpx=0.5px=1物理像素。微信小程序建议设计以iPhone6为准样式的使用：class=\"container\">\r\n\r\npage使用Page()函数来注册一个页面，为其指定页面的初始数据，生命周期函数，事件处理等。data 页面的初始数据，可以使用setData更新定义的数据onLoad 页面加载事件onReady 页面渲染完成onShow 页面显示onHide 页面隐藏onUnload 页面卸载例如:Page({\r\n  data: {\r\n    logs: []\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      logs: (wx.getStorageSync('logs') || []).map(function (log) {\r\n        return util.formatTime(new Date(log))\r\n      })\r\n    })\r\n  }\r\n})page另外使用的文件.wxml是页面文件，使用定义好一套标签语言，.wxss是局部样式文件，.json局部配置文件比如需要在一个单独的页面中设置他的navigationBarTitleText,可以在.json文件中设置:{\r\n    \"navigationBarTitleText\": \"日志文件\"\r\n}源代码地址:https://github.com/jjz/weixin-mina"}
{"title": "有渔微信小程序系统概述《一》认识微信小程序与HelloWorld ", "author": "天下雪", "pub_time": "2016-10-23 12:11", "content": "认识微信小程序一、当前APP的痛点1. 用户的痛自从买了智能手机后，手机上装了一堆APP，每次装一个新应用就必须下载安装一个APP。这手机屏幕成了百货展厅，每次找个APP还得滑动屏幕找白天；而且每次安装一个APP，就占用大量空间，这手机容量也越来越不够用了。一次跟一位做运营的朋友聊天，他说现在只在微信上做推广，因为微信上客户群体多。他说知名度小的APP很难推，一是推广费用高，二是客户一般也不愿下载。 2. 开发者的痛现在做互联网的，开发了PC端的WEB后，再开发Android和Apple版，几乎是标配。我也曾经赶过这趟浑水，当时团队开发完了PC端的WEB，然后自然就想到要开发Android和Apple版。但问题来了：我们团队人少，而且大家都没APP开发经验；哪就找外包呗？于是我们就去找外包公司。后来在聊天中外包公司的老大就向我吐苦水，他说现在1个Android，1个Apple团队，1个项目必须得养2帮人马，开发成本太高了。后来，为了省财力、时间，我就让外包公司开发一个APP的外壳，然后里面打开浏览器访问我们的WAP网站，也就是Hybrid APP解决方案。Hybrid APP解决方案虽然开发便捷，但在用户体验上就比原生的APP差很多。 二、微信小程序方便了用户，更方便了开发者什么是小程序？小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不关心是否安装太多应用的问题。应用将无处不在，随时随地可用，但又无需安装卸载。微信小程序解决了当前APP的痛点，方便了用户，更方便了开发者。从本质上看，微信小程序有点类似Hybrid APP解决方案。以后微信就成为移动端入口，用户不用再无休止地安装APP了；开发者只需要用javaScript一种语言就可以了，开发成本几乎可省下2/3以上；而且微信提供了非常丰富的API，微信小程序的用户体验肯定不会比原生的APP差。微信作为国内最大的交友平台，已经成了一个独立的互联网王国，上面有大量的用户资源，微信小程序推广的性价比就非常高。   可以想象，再过一段时间，大量的APP开发者会转投微信小程序的大营，而且几乎所有的APP都会重新再开发一个微信小程序版本，微信小程序开发人员的需求也会非常大。所以，作为一名互联网从业人员，学习掌握微信小程序开发是非常有必要的。HelloWorld微信小程序看千遍不如做一遍。先让我们来一起做一个最简单的HelloWorld吧。    1.下载安装微信小程序开发者工具，下载路径：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html根据你的操作系统类型，选择windows 64、windows 32或mac。     2.创建项目    ⑴ 添加项目    点击“添加项目”按钮，创建一个项目。⑵ 项目的几个参数说明    没有 AppID 就选无AppID（如果乱写会报错，到时可能无法进入项目）。如果你选择的“项目目录”为空，请如图所示勾选在“当前目录中创建quick start项目”。项目名称就随便写一个吧，比如“测试项目”。点击“添加项目”按钮，一个最简单的微信小程序就完成了。3.项目代码结构说明    点击开发者工具左侧导航的“编辑”，我们可以看到这个项目已经初始化并包含了一些简单的代码。其中包括：app.js，app.json，app.wxss和2个目录：pages，utils。     其中，最重要的是 app.js、app.json、app.wxss 这三个文件。    app.js：这个文件是整个小程序的入口文件。    app.json：这个文件是小程序的全局配置文件，决定页面文件的路径，窗口表现，设置网络超时时间等。app.wxss：是小程序的样式文件，你可以把它想象成html中的CSS。"}
{"title": "有渔微信小程序系统概述《二》了解.js文件及.json文件 ", "author": "天下雪", "pub_time": "2016-10-23 12:17", "content": "了解.js文件1、app.jsapp.js是整个小程序的入口文件，也是控制整个小程序生命周期的文件。App.js用App()来实现对整个程序的注册，同时App()里面还实现了对小程序生命周期的监控函数(onLaunch, onShow, onHide)。APP()内部参数说明：属性类型描述触发时机onLaunchFunction生命周期函数--监听小程序初始化当小程序初始化完成时，会触发onLaunch（全局只触发一次）onShowFunction生命周期函数--监听小程序显示当小程序启动，或从后台进入前台显示，会触发 onShowonHideFunction生命周期函数--监听小程序隐藏当小程序从前台进入后台，会触发 onHide其他Any开发者可以添加任意的函数或数据到Object 参数中，用 this 可以访问     我们来看一个app.js的代码：//app.jsApp({  onLaunch: function () {    ... ...  },  getUserInfo:function(cb){    ... ...  },  globalData:{    userInfo:null  },  onShow: function(){    ... ...  },  onHide: function(){    ... ...  }}) 小程序前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。简单地说，前台就是你在操作小程序时；后台就是你离开了小程序，去玩手机的其他东西去了，这时小程序就隐藏到后面去了。 2、index.js小程序中每一个页面可以放在一个文件夹中，这个文件夹中一般包括4个文件：.js, .json, .wxml, .wxss。官方建议这四个文件的名字最好和文件夹的名字一致，这样便于框架自动查找。每个页面都需要注册，index.js用Page()这个函数来注册一个页面，它接受一个object参数，用这个参数来指定页面的初始数据，生命周期函数，事件处理函数。 Page()内部参数说明：属性类型描述dataObject页面的初始数据onLoadFunction生命周期函数--监听页面加载onReadyFunction赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nhgf\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              有渔微信小程序系统概述《一》认识微信小程序与HelloWorld \n              有渔微信小程序系统概述《三》view层及小程序框架概述 \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n                                    \n                  • 有渔微信小程序系统进阶《四》小程序组件\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJMrVoO', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n简易商城小程序全栈开发(mpvue+koa+mongodb2018-07-27初试小刀自我简历小程序2018-08-08微信小程序使用相机2018-07-27「小程序JAVA实战」微信小程序简介（一）2018-08-10「小程序JAVA实战」微信小程序的简要注册流2018-08-10\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1534149087|4e277dbea1c3ae70301b11a1fce7ef42|2';"}
{"title": "有渔微信小程序系统概述《三》view层及小程序框架概述 ", "author": "天下雪", "pub_time": "2016-10-23 12:25", "content": "小程序的view层MVC模式这里就不讲了，不懂MVC模式的就自己去查阅相关资料。小程序的的view层由WXML与WXSS编写，由组件来进行展示。view层将逻辑层的数据反应成界面显示，同时将界面发生的事件发送给逻辑层。WXML(WeiXin Markup language)用于描述页面的结构，可以想象成Html文件。WXSS(WeiXin Style Sheet)用于描述页面的样式，可以想象成Css文件。组件(Component)是视图的基本组成单元，可以想象成Html中的组件。下面我们用简单的例子来看看 WXML 具有什么能力： 1、测试环境准备⑴ pages目录里建立viewtest目录，专门用来做view层测试。⑵ index里添加触发viewtest的相关代码① index.wxml修改成：② index.js添加下面的代码：  bindUserTap: function() {    wx.navigateTo({      url: '../viewtest/viewtest'    })  },③ app.json把viewtest路径加入pages参数里：  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/viewtest/viewtest\"  ], 2、例子⑴ 数据绑定<!--viewtest.wxml--><view> {{message}} </view>// viewtest.jsPage({  data: {    message: 'Hello MINA!'  }}) ⑵ 列表渲染<!--viewtest.wxml--><view wx:for=\"{{array}}\"> {{item}} </view>// viewtest.jsPage({赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              有渔微信小程序系统概述《二》了解.js文件及.json文件 \n              有渔微信小程序系统概述《六》小程序的API \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n                                    \n                  • 有渔微信小程序系统进阶《四》小程序组件\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJMrVoO', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n简易商城小程序全栈开发(mpvue+koa+mongodb2018-07-27初试小刀自我简历小程序2018-08-08微信小程序使用相机2018-07-27「小程序JAVA实战」微信小程序简介（一）2018-08-10「小程序JAVA实战」微信小程序的简要注册流2018-08-10\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1534149088|585bed12ee2e943bac48ee21a9f8f7f9|2';"}
{"title": "有渔微信小程序系统进阶《四》小程序组件 ", "author": "天下雪", "pub_time": "2016-10-23 12:34", "content": "组件(Component)是小程序视图的基本组成单元，可以把它想象成Html中的组件，你可以通过组合这些基础组件快速开发小程序的界面。小程序的组件包括以下内容：大类具体组件说明视图容器view视图scroll-view可滚动视图区域swiper滑块视图区域赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n              微信小程序实战教程：火车票查询，直取12306数据 \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n                                    \n                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJMrVoO', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n微信小程序：一个json帮你完成分享朋友圈图2018-07-16小程序开发技巧总结2018-07-20基于后端云微信小程序开发2018-07-25【微信小程序】性能优化2018-07-17微信小程序仿APP section header 悬停效果2018-07-20手把手教你搭建小程序音视频2018-07-19喂，快给我打一个小程序预览码2018-07-17微信小程序Java登录流程（ssm实现具体功能2018-07-19精确计算微信小程序scrollview高度，全机型2018-07-19\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\nwordpress开源微信小程序2018-08-13获取运动数据2018-08-10一个简洁的音乐、图文微信小程序【小独Lite2018-08-08一个后端撸了一个小程序，表情包小程序2018-08-06求大神帮忙写下这个2018-08-05微信小程序demo：rss阅读器，含注释级源码2018-08-05微信小程序Demo：今日幸运签2018-07-25微信小程序Demo：2life-双生微信小程序2018-07-25手持弹幕来袭2018-07-25\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1534149089|c67b39d97caa1a60f87f8deca91c3dd4|2';"}
{"title": "微信小程序开发常见问题分析 ", "author": "天下雪", "pub_time": "2016-10-19 14:43", "content": "距离微信小程序内测版发布已经有十几天的时间了，网上对微信小程序的讨论也异常火爆，从发布到现在微信小程序一直占领着各种技术论坛的头条，当然各种平台也对微信小程序有新闻报道，毕竟腾讯在国内影响力还是很大的。我们都知道微信小程序第一天发布内测版，并没有公开官方开发文档和开发工具，但是这阻止不了技术人的好奇心。因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以立马做了一下小demo，水平有限，所以做的过程也就是一个学习的过程，一个提高的过程。这篇文章主要写我在写demo的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰。一：项目结构微信小程序项目结构主要有四个文件类型,如下WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，js 逻辑处理，网络请求json 小程序设置，如页面注册，页面标题及tabBar。注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。在根目录下用app来命名的这四中类型的文件，就是程序入口文件。app.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。app.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。app.wxss全局配置的样式文件，项目非必须。知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。二：常见问题rpx（responsive pixel）微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。40013错误在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。4058错误微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。Page注册错误这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.Page route错误字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用组件，一种是调 wx.navigateTo。如下代码：wxml文件：搜索js文件事件处理函数：bindtap:function(event){wx.navigateTo({url: “search/search”})}如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码<navigator url=\"search/search\">\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\n</navigator>\r\n这种也是不允许的，也就是说组件内部不能再嵌套组件。它只能是单层存在的。Do not have * handler in current page.大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。bindtap:function(event){\r\n  wx.navigateTo({\r\n    url: \"search/search\"\r\n  })\r\n},\r\ntabBar设置不显示对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种注册页面即将页面写到app.json的pages字段中，如\"pages\":[\r\n   \"pages/message/message\",\r\n   \"pages/contact/contact\",\r\n   \"pages/dynamic/dynamic\",\r\n    \"pages/dynamic/music/music\",\r\n   \"pages/index/index\",\r\n   \"pages/logs/logs\"\r\n ]\r\ntabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。tabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册tabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是”pages”中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。tabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。navigationBarTitle显示问题通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。若你不了解生命周期，可以点击查看Page({data:{// text:”这是一个页面”},onLoad:function(options){// 页面初始化 options为页面跳转所带来的参数  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏\r\nwx.setNavigationBarTitle({\r\n  title: '音乐'\r\n})\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})\r\n通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。{“navigationBarTitleText”: “音乐”}wx.navigateTo无法打开页面一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo本地资源无法通过 css 获取background-image：可以使用网络图片，或者 base64，或者使用标签页面间数据传递微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在”?”后面，多个参数直接用”&”符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。<navigator url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">\r\n         <view class=\"item\" >\r\n            <view class=\"item-left\">\r\n                 <image src=\"{{item.url}}\" class=\"image\"/>\r\n            </view>\r\n            <view class=\"item-middle\">\r\n                 <view>\r\n                      <text class=\"title\">{{item.title}}</text>\r\n                 </view>\r\n                 <view>\r\n                     <text class=\"message\">{{item.message}}</text>\r\n                 </view>\r\n           </view>\r\n           <view class=\"item_right\">\r\n               <view><text class=\"time\">{{item.time}}</text></view>\r\n               <view class=\"mark\" wx:if=\"{{item.count>0}}\"><text class=\"text\">{{item.count}}</text></view>\r\n           </view>\r\n        </view>\r\n        <view  class=\"line\"></view>\r\n      </navigator>\r\n而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下/**  作者：dushao\r\n *   新浪微博：http://weibo.com/dushaoxiaoxiao\r\n *   博客  :    http://www.takozhang.cn\r\n * */\r\n * \r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    isHiddenToast:true\r\n  }\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(options.title)\r\n     console.log(options.message)\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"/pages/message/search/search\"\r\n})\r\n  },\r\n})\r\n这样就实现了页面间数据传递功能。"}
{"title": "微信小程序官方文档个人分析心得 ", "author": "天下雪", "pub_time": "2016-10-19 15:20", "content": "首先从官方文档给的框架说起,微信小程序官方文档给出了app.js, app.json, app.wxss. 先从这三个文件说起.  - app.js 这个文件是整个小程序的入口文件,开发者的逻辑代码在这里面实现,同时在这个文件夹里面可以定义全局变量. - app.json 这个文件可以对小程序进行全局配置,决定页面文件的路径,窗口表现,设置网络超时时间,设置多tab等. - app.wxss 是小程序的公共样式表.(为了适应广大的前端开发者，我们的 WXSS 具有 CSS 大部分特性。 同时为了更适合开发微信小程序，我们对 CSS 进行了扩充以及修改。)接着我们就结合官方给出的代码具体说一下上面提到的三个文件.首先说的是配置文件app.json.下面是官方给出的例子.{\"pages\": [ \"pages/index/index\", \"pages/logs/index\" ],\"window\": { \"navigationBarTitleText\": \"Demo\" },\"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" }] }, \"networkTimeout\": { \"request\": 10000, \"downloadFile\": 10000 },\"debug\": true}官方给出了app.json五个配置项列表.(pages(Array), window(Object), tabBar(Object), networkTimeout(Object), debug(Boolean)),接着我们就详细的分下一下这几个配置项.pages它的作用是配置小程序的页面,这个配置项是必填的,它接受一个数组,里面的每一项都是字符串,从上面给出的代码: \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ] 可以看出,每一项分别对应的都是实现文件的路径以及他的文件名. 注意:这个配置里面的第一行配置是它的初始页面,例如上面代码的初始页面就是indexwindow这个配置项是用来设置小程序的状态栏、导航条、标题、窗口背景色。他给出了六个属性(navigationBarBackgroundColor(HexColor), navigationBarTextStyle(String-(black,white)), navigationBarTitleText(String), backgroundColor(HexColor), backgroundTextStyle(String-(dark,light)), enablePullDownRefresh(Boolean)),开发者可以根据自己的需求来进行配置.我们详细说一下这几个属性分别的功能: navigationBarBackgroundColor 它是用来设置导航栏背景颜色,这个属性要输入的是十六进制颜色值.navigationBarTextStyle 它是用来导航栏标题颜色的,它的输入类型是字符串(String),但是现在官网给出的文档目前仅支持(black和white)这两种颜色. navigationBarTitleText 这个属性是显示导航栏标题内容的,开发者可以根据自己的需要来进行设置. - backgroundColor 这个属性是设置窗口的背景色的,它需要输入的也是十六进制颜色值的. backgroundTextStyle 这个属性我的理解是设置窗口内容的样式的,官方给出的标准说明是下拉背景字体、loading 图的样式,这个属性同navigationBarTextStyle属性一样目前仅支持两种颜色(dark和light). enablePullDownRefresh 这个属性是设置是否开启下拉刷新,默认是开启的,注意: 在这个配置文件(app.json)中如果关闭了下拉刷新,当你在你自己开发的页面中想要设置下拉刷新也是行不通的,也就是说如果你想要在以后页面中使用下拉刷新这个功能,就必须保证这个配置文件中的这一项设置是打开的.上面给出的示例代码:{\"window\":{ \"navigationBarBackgroundColor\": \"#ffffff\",           \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\",\"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\"          }}显示出来的效果是这样的:tabBar这个配置项是用来配置页面底部的tab栏的,开发者可以根据自己的需求来进行配置.注意: tabBar是一个数组,只能配置最少2个,最多5个,而且tab栏的顺序是按照数组的排序来的.tabBar官方给出了一下五个属性(color(HexColor), selectedColor(HexColor), backgroundColor(HexColor), borderStyle(String), list(Array) ).接下来说说我对这五个属性的理解: color 设置tab上的文字默认颜色 selectedColor 设置tab上的文字选中的颜色 backgroundColor 设置tab的背景颜色 borderStyle 设置边框的颜色,现在仅支持(black和white)上面这四个属性就是按照官方给出的API来设置就可以,下面说一下list属性.list属性接受的是一个数组(Array),在list下面配置的每一项都是一个对象,他们都有以下这四个属性(pagePath(String), text(String), iconPath( String), selectedIconPath(String)).pagePath 这个定义的是页面的路径,但是这个属性定义的路径必须是在pages上定义过的.text 设置的是按钮上的文字iconPath 是定义icon图片的路径,这个属性定义的图片大小不超过40kb selectedIconPath 定义的是当选中按钮之后显示的图片,同样图片的大小不能超过40kb.下面是官方给出的效果图:networkTimeout它是用来设置各种网络请求的超时时间的,单位是毫秒,官方给出了四个属性(request, connectSocket, uploadFile, downloadFile)这四个属性分别定义的是wx.request, wx.connectSocket, wx.uploadFile, downloadFile 这四个API的超时时间.debug如果在app.json将debug配置为true,那么在开发者工具的控制台面板中可以输出详细的调试信息.以上就是根据官方给出的文档,我学习之后对app.json配置一些心得,下面我们在看一下app.js 这个文件.可以看到app.js这个文件的后缀是js,没错,微信小程序的开发框架在逻辑层用的语言就是JavaScript.但是微信小程序也在JavaScript的基础上做了一个修改,可以称之为一个新的轮子.这个框架可以使开发者更加方便的调用一些微信的功能,例如扫一扫,微信支付等一些微信特有的功能.我们接着回到app.js这个文件中来,其他的稍后再说.这个文件是整个小程序的入口文件,也可以说是控制整个小程序生命周期的文件,那么我们就不难想象,我们在这个文件中应该实现的几个功能,首先我们肯定需要对整个程序进行注册,正好微信给我们提供了一个app()来实现对整个程序的注册,同时app()里面还实现了对小程序生命周期的监控函数(onLaunch, onShow, onHide), 其中onLaunch是监听小程序初始化,当初始化完成时会触发onLaunch,当然这个函数是全局只触发一次.onShow是监听小程序的显示,在小程序启动时候,或者当你从后台进入到前台的时候就会触发这个函数.而onHide函数是监听小程序的隐藏的,当你从前台切换到后台的时候,会触发onHide.有了这些一个小程序的实例基本上算是完成了,当然为了让开发者加入更多自己的逻辑,微信还提供了让开发者在app()中加入自己的逻辑,开发者可以可以添加任意的函数或数据到 Object 参数中，用 this 可以访问.注意:app()只能定义在app.js中,而且不能注册多个.当在app.js中注册了实例之后,如果你想在自己的逻辑页面调用它,你可以用getApp()这个全局函数,这样你就可以全局调用app()里面的数据.微信给出的官方代码如下:var appInstance = getApp()console.log(appInstance.globalData) // I am global data注意:getApp()获取里实例之后,不要私自调用生命周期函数. 而且不要在app.js中用getApp()函数,用this就可以调用app()里面的东西. 基本上app.js就这些东西,还有一些API里面的内容会在后面一一介绍.下面我们就看一下app.wxss这个文件,一般来说做过网站开发的(我自己是用php来开发的,这是我个人的一点拙见,如有不对请见谅)相信对css写在单独的文件中应该不会陌生,这个app.wxss也是类似的,不过他的的配置是针对全局的,也就是说如果你在后面的page中没有重新配置他,那么他就会调用这个文件中的样式设置,但是如果你有个人需求,需要在每个页面重新写样式,那也没关系,他会自动覆盖宰割文件中的样式. 当你重新创建一个微信小程序他就会出现这几个文件,以上是我结合官方文档对他们的一些理解,接下来就是page的逻辑,视图,配置的一些心得.page这一块就是开发者自己的业务实现文件了. 每一个页面可以放在一个文件夹中,这个文件夹中一般包括.js, .json, .wxml, .wxss 这四个文件,微信官方还建议这四个文件的名字最好和文件夹的名字一致.这个便于框架自动查找,不需要做更多的配置. 当你开始做页面的功能的时候这个时候在.js,也需要注册,微信官方给出Page()这个函数来注册一个页面,他接受一个object参数,用其来指定页面的初始数据,生命周期函数,事件处理函数.需要注意的是当你在注册这个页面的时候要确定在最开始的app.json这个配置文件中已经配置过这个页面,而且当你对程序有所改变的时候也要确保app.json这个文件中的内容也随之相应改动.微信给Page()函数一下几个属性(data(Object), onLoad(function), onReady(Function), onShow(Function), onHide(Function), onUpload(Function), onPullDownRefresh(Function)),而且你也可以添加任意函数或者数据到object参数中,在这个页面用this即可访问.下面就简单的介绍一下这几个官方给出的属性: data - 实现页面的初始化数据 onLoad - 是生命周期函数,用来监听页面加载,一个页面只会调用一次,它的参数可以获取wx.navigateTo和wx.redirectTo及< navigator/>中的query. onReady - 同样是生命周期函数,用来监听页面初次渲染完成,一个页面只会调用一次,代表页面已经准备妥当,可以和视图层进行交互.对页面的设置请在onReady之后设置,如wx.setNavigationBarTitle. onShow - 生命周期函数,用来监听页面显示,每次页面打开都会调用一次. onHide - 生命周期函数,监听页面隐藏'',当wx.navigateTo或者底部tab切换之后调用. onUpload - 生命周期函数,用来监听页面卸载.当wx.navigateTo和 navigateBack的时候调用. onPullDownRefresh - 页面相关事件处理函数,用来监听用户的下拉动作.但是需要在config的window选项中开启enablePullDownRefresh,当数据刷新完成之后,可以用wx.stopPullDownRefresh停止当前页面的下拉刷新. 下面是微信给出的官方代码:Page({     data: {         text: \"This is page data.\"     },     onLoad: function(options) {     // Do some initialize when page load.     },     onReady: function() {       // Do something when page ready.     },     onShow: function() {     // Do something when page show.     },     onHide: function() {         // Do something when page hide.       },     onUnload: function() {         // Do something when page close.     },     onPullDownRefresh: function() {     // Do something when pull down       },     // Event handler.     viewTap: function() {       this.setData({ text: 'Set some data for updating view.'     })   }})上面说了用data属性来设置页面的初始化数据,但是如果我们想改变数据里面的值,怎么办??那么我们就介绍一个微信官方给我们提供的setData()函数,这个函数可以将数据从逻辑层发送到数据层,同时还可以改变this.data的值.setData()接受一个对象参数,让数据以key,value的形式表示将this.data中key对应的值改变成value.下面是微信官方给出的page的生命周期的图片:在小程序中的所有页面路由全部由框架进行管理,对于路由的触发方式以及页面的生命周期函数可以通过调用API来进行..下面我们就简单的介绍一下微信小程序的API.微信小程序框架给我们提供了丰富的微信原生API,可以方便的调用微信提供的能力,如获取用户信息,本地存储,支付功能等.下面是微信关于API提供的说明:wx.on 开头的API是监听某个事件发生的API接口,接受一个CALLBACK函数作为参数,当事件触发时,会调用CALLBACK函数. 如未有特殊约定,其他API接口都接受一个object作为参数. OBJECT 可以指定success,fail,complete来接受接口调用结果.OBJECT参数API的具体调用请看 微信小程序API文档因为现在微信小程序还在内测期间,我也没有内测号,所以具体的调用API代码需要在微信小程序开放之后,根据具体的逻辑进行实现.而且微信API文档已经给的非常清楚,相信调用不会太过困难.上面的这些就是微信小程序page的页面注册以及API功能实现，但是我们知道光有这些是不够的，在互联网发展到现在我们更加注重的是人机交互，让用户有一个更好的体验才算是 一个好的程序，那么接下来我们就讲讲微信小程序是如何对页面进行渲染的。在微信小程序中采用了微信自己原生的渲染方式。微信小程序的页面布局采用的是wxml，然后结合基础组件，事件系统构建出来页面的结构。wxml中有数据绑定，条件渲染，列表渲染， 模版，事件， 引用这几种方式，下面我们就具体说说这几种方式。数据绑定 在上面我们已经说过了在Page()注册页面的时候，里面会有一个data属性来定义初始化数据，现在页面渲染的数据绑定的时候就需要调用data里面的数据了。下面看一下官方给出的例子。<view> {{ message }} </view>Page({ data: { message: 'Hello MINA!' }})从上面的代码可以看出来在视图层接受逻辑层的代码的时候需要用2个大括号把数据的键值包起来就可以得到数据的值。当然在视图层还可以进行运算（三元运算，算术运算），逻辑判断，字符串运算，而且还可以在大括号里面进行组合（数组，对象（虽然可以随意组合，但是如果后面的变量名和前面的变量名相同的话，那么后面的会覆盖前面的））。条件渲染 顾名思义所谓的条件渲染，就是通过条件来判断是否需要渲染该代码块。条件渲染主要是用到wx:if 和 block wx:if 这两个，第一个相信好理解，第二个是在block里面进行条件渲染，这里我们特别说明一下< block/>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。和我们以前的逻辑编程类似，既然有了wx:if ，那么我们也会有wx:elseif和wx.else，这几个组合起来，可以使条件渲染更加灵活。在这里官方文档中提到了一个wx:if和hidden的对比，通过合理的运用这两种方法可以使你的程序更优。下面我们就是说说他们俩的区别：因为wx:if之中也可能包含数据绑定，所以当wx:if的条件值切换时，框架有一个局部渲染的过程，他会确保条件在切换是销毁或者重新渲染。同时wx:if也是有惰性的，如果初始渲染条件为false,框架什么也不会做，只有在条件第一次变为真的时候才会开始渲染。相比之下hidden就简单的多，组件始终都会被渲染，只是简单的控制显示和隐藏，一般来说，wx：if 有更高的切换消耗，而hidden有更高的初始渲染消耗，你可以根据自己的需求来调用。列表渲染 -- wx:for下面我们就说说wx:for的用法，wx:for绑定一个数组，就可使用数组中各项数据重复渲染该组件，注意默认数组的当前项的下标变量名默认为index，数组当前项的变量名为item，，当然你也可以根据自己的需要来重新定义这两个名字，使用wx:for-item可以指定数组当前元素的变量名，wx:for-index可以指定数组当前下标的变量名，wx:for也可以嵌套，这个时候就需要改变默认框架给定义的名字了。下面是官方给出的事例代码：<view wx:for=\"{{items}}\"> {{index}}: {{item.message}}</view>Page({ data: { items: [{ message: 'foo', }, { message: 'bar' }] }})<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">   {{idx}}: {{itemName.message}}</view>模版WXML提供模版(template),可以在模版中定义代码片段,然后在不同的地方调用.微信小程序的模版可以用name来命名它的名字,在使用的时候用is来声明使用的模版,然后将模版所需要的data传入即可,下面我们用官方文档给的代码来看一下如何声明及调用模版.<!--  index: int  msg: string   time: string--><template name=\"msgItem\">   <view>     <text> {{index}}: {{msg}} </text>     <text> Time: {{time}} </text>   </view></template>上面这段代码可以看到模版的名字是\"msgItem\".<template is=\"msgItem\" data=\"{{...item}}\"/>在调用的时候使用方法如上,在is属性加上模版的名字即可.后面还有一个data属性,并且在里面还加入数据,下面我们就看一下下面这段代码.Page({ data: { item: { index: 0, msg: 'this is a template', time: '2016-09-15' } }})<template name=\"odd\">   <view> odd </view></template><template name=\"even\">   <view> even </view></template><block wx:for=\"{{[1, 2, 3, 4, 5]}}\">   <template is=\"{{item % 2 == 0 ? 'even' : 'odd'}}\"/></block>通过上面对条件渲染的介绍,我们可以看到在循环掉数组[1,2,3,4,5]之后item数组属性在三元运算中判断调用哪一个模版.在这儿再多说一句模版也有自己的作用域,只能使用data传入的数据,当然data传入的数据可以是你自己新建的数据,也可以是你在配置中写好的初始化数据.好了现在我们说完模版了,可能有的同学就该想了,我写好模版之后该如何调用它,如果他们是在一个页面那肯定没问题,但是这样的话可用性还是很差啊,如果我想把模版单独放在一个页面,在调用它的时候该怎么办啊?没关系,微信小程序早就考虑到了,那么我们接下来就说说引用.引用WXML提供两种引用方式import和include.接下来我们就先说说import这种方式,我们就结合代码来看,它调用在不同页面的模版消息如下:<!-- item.wxml --><template name=\"item\">   <text>{{text}}</text></template>在 index.wxml 中引用了 item.wxml，就可以使用item模板：<import src=\"item.wxml\"/><template is=\"item\" data=\"{{text: 'forbar'}}\"/>这里要注意一下,import引用也是有作用域这个概念存在的,它只会定义import目标文件中定义的template,而不会import目标文件import中的template.简而言之就是import只能引用template而不能引用import.上面说了import是如何引用的,那么我们接着看一下include是怎么引用的.include引用和import唯一不同点就是他的引用相当于复制,他会复制< template>里面的全部内容,但是不包含< template>,看一下代码相信你可以理解的更加明白.<!-- index.wxml --><include src=\"header.wxml\"/><view> body </view><include src=\"footer.wxml\"/><!-- header.wxml --><view> header </view><!-- footer.wxml --><view> footer </view>上面我们说的视图层这些方法已经可以构成一个静态的页面了,但我们现在是21世纪啊,一个没有人机交互的程序怎么能在这个世界生存下来了?在用户体验至上的今天,微信小程序不可能不考虑到这一点,接下来我们就说说视图层的事件方法.先来说说什么是事件,相信有的人看到这儿肯定是一脸懵逼,你这说的啥玩意儿,说的这么专业,我还不如看文档去.那么我们就说说什么是事件. 事件就是一种页面到逻辑层的通讯方式,比如说你的操作想得到机器的反馈,这时候就用到事件了.事件可以将用户的行为反馈到逻辑层进行处理. 说到这儿不禁又有一个问题,那他是怎么用的呢? 事件可以绑定到组件上,当触发事件,就会执行逻辑层对应的事件处理函数,当然为了更加方便人机交互,用户还可以携带额外的信息,如id,data等.可能有人看完刚才的一段就说了,好了,你刚才说的事件解释的差不多了,可是你为什么有冒出一个组件,这让我这么理解?既然说到组件了,我们就先简单的了解一下,在之后的组件板块再详说,先保证大家能看懂什么是事件就好了.为什么要有组件呢?组件是框架为了开发者进行快速的开发而设计的.那什么是组件呢? 组件是视图层的基本组成单元,在微信小程序中组件自带一些功能与微信风格的样式,一个组件通常包括开始标签和结束标签,属性是用来修饰这个组件,内容在两个标签之内.<tagname property=\"value\"> Content goes here ...</tagename>在这里需要注意一点,组件和属性都是小写,并且以\"-\"进行连接.简单的介绍一下组件,那我们继续说事件.事件分为冒泡事件和非冒泡事件,冒泡事件是当一个组件上的事件被触发后,该事件会向父节点传递,而非冒泡事件则不会.现在微信小程序给出的冒泡事件仅仅有6个(touchstart,touchmove, touchcancel,touchend,tap, longtap),下图是他们分别对应的触发条件.冒泡事件类型剩下的都属于非冒泡事件.接下来我们就说说事件怎么用?事件是通过事件绑定来实现的.它的写法是以key,value的形式来写的.key以bind 和catch 开头,然后跟上事件的类型. value 是一个字符串,需要在对应的page中定义同名的函数,不然当触发事件的时候会报错.(bind 事件绑定不会阻止冒泡事件向上冒泡,而catch 可以阻止冒泡事件向上冒泡).说完了如何进行事件绑定了,我们再说说,当事件触发是逻辑层的事件处理函数会收到什么? 事件处理函数会收到一个事件对象. 那么这个事件对象里面都有什么属性呢?? 里面的属性有(type, timeStamp, target, currentTarget, touches, detail),下面是他们的一些说明:事件对象属性type得到的是通用事件类型,例如tap. timeStamp是页面打开到事件触发所经过的毫秒数. target触发事件的源组件,它包括事件源组件的id,data-开头自定义属性的组成的集合(dataset),以及他在坐标系统中的偏移量. currentTarget 触发事件的当前事件,它包括的内容与target相同.其他的属性按照上面的说明简单了解即可,在这里我们说一下target和currentTarget中的dataset,我们知道在组件中可以定义数据,这些数据会通过事件传递给 SERVICE书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。用一段代码来说话相信大家就更清楚了.<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>\r\n\r\nPage({ \r\n  bindViewTap:function(event){ \r\n    event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法 \r\n    event.target.dataset.alphabeta == 2 // 大写会转为小写 \r\n  }\r\n})我不知道大家感觉怎么样,要是我自己刚开始看我写的这一大段内容,我感觉我就该骂娘了,不是说么NO图NO BB,下面我就给大家上代码,相信看完之后事件这一块基本上就明白了.//视图层的事件绑定<view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>//逻辑层的事件处理函数Page({ \r\n  tapName: function(event) { \r\n    console.log(event)\r\n }\r\n})//逻辑层的事件处理函数输出的信息//逻辑层的事件处理函数输出的信息\r\n{\r\n\"type\": \"tap\",\r\n\"timeStamp\": 1252,\r\n\"target\": { \r\n  \"id\": \"tapTest\", \r\n  \"offsetLeft\": 0, \r\n  \"offsetTop\": 0, \r\n  \"dataset\": { \"hi\": \"MINA\" }\r\n},\r\n\"currentTarget\": { \r\n  \"id\": \"tapTest\", \r\n  \"offsetLeft\": 0, \r\n  \"offsetTop\": 0, \r\n  \"dataset\": { \"hi\": \"MINA\" }\r\n},\r\n\"touches\": [{ \r\n  \"pageX\": 30, \r\n  \"pageY\": 12, \r\n  \"clientX\": 30,\r\n  \"clientY\": 12, \r\n  \"screenX\": 112, \"screenY\": 151\r\n}],\r\n\"detail\": { \"x\": 30, \"y\": 12}}到这儿WXML的页面结构就说完了,接着我们简单说说WXSS就基本说完了.在WXSS中引入了新的 尺寸单位rpx 它规定1rpx=0.5px = 1物理像素WXSS的样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束.剩下的内容基本上和css相差不大,有兴趣的可以看一下官方文档WXSS"}
{"title": "教你如何在微信小程序中使用 Hprose ", "author": "天下雪", "pub_time": "2016-10-19 18:20", "content": "微信小程序 SDK 刚刚出来，就已经有一堆入门教程了。然而并没有关于如何在微信小程序中进行网络通讯的教程，所以我们今天就来讲一下新鲜出炉的独门绝技——hprose 如何在微信小程序中实现通讯。\r\n首先下载微信小程序开发工具，之后安装。\r\n然后按照网上那一堆微信小程序 Hello World 教程创建一个小程序。\r\n接下来我们下载 hprose-html5 或者 hprose-js。推荐使用 hprose-html5 版本，这个版本更小，支持二进制数据传输，而且更快。\r\n可以用 git clone 下载，也可以只下载 dist 目录下的文件，以 hprose-html5 版本为例：\r\nhprose-html5.src.js 是源码版本 hprose-html5.js 是压缩版本\r\n这两个版本都可以用。调试阶段建议用源码版本。但不要使用 hprose-html5.min.js 版本，这个版本是压缩版本的，不支持在微信小程序中编译。\r\n之后，你可以把它们复制到你创建的那个微信小程序的 utils 目录下（复制其中一个就可以），然后将它改名为 hprose.js（这一步可选，只为后面引用的时候，名称统一）。\r\n接下来，打开 pages/index/index.js 文件。\r\n在开头加上：\r\nvar hprose = require('../../utils/hprose.js');\r\n然后在 onLoad 事件中加入以下代码：\r\nvar client = hprose.Client.create(\"http://www.hprose.com/example/\", [\"hello\"]);client.hello(\"world\", function(result) {  console.log(result);});\r\n总体看上去是这样的：\r\n//index.jsvar hprose = require('../../utils/hprose.js');//获取应用实例var app = getApp()Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //事件处理函数  bindViewTap: function() {    wx.navigateTo({      url: '../logs/logs'    })  },  onLoad: function () {    console.log('onLoad')    var client = hprose.Client.create(\"http://www.hprose.com/example/\", [\"hello\"]);    client.hello(\"world\", function(result) {      console.log(result);    });    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据      that.setData({        userInfo:userInfo      })    })  }})\r\n然后点编译，运行，如果你的网络没有问题的，你会在调试控制台中看到：\r\n这里写图片描述\r\n好了，就这么简单，接下来，你就可以用 hprose 来做微信小程序开发了。"}
{"title": "微信小程序开发工具安装指南及注意事项 ", "author": "天下雪", "pub_time": "2016-10-19 19:02", "content": "这两天闲来无事，也安装了 “微信折叠”的开发工具来玩一下。以下是一些小道消息及使用体验，过两天我会写一篇文章以开发者的角度来详细评价微信小程序:微信小程序不能开发游戏类、直播类功能，小程序每个人关注的上限是20个（还不确定，不过我相信这是真的，这次公布的API里并没有视频组件。微信太大，苹果要有所顾忌，但是微信也要做出相应的让步)微信目前有没有同苹果商谈好，还是个未知数，毕竟会对AppStore有一定的冲击。抛弃了大量的javascript组件后，这个生态体系变得相当的封闭，微信解释肯定是：为了更好的性能提升。那么我们拭目以待。小程序的入口是微信里的三级菜单，就是在“Tab栏发现里的游戏下面加入一个“小程序”。反正，这一栏里的购物和游戏我是从来没点进去过的。以腾讯的尿性，小程序同服务号一样，其关系链及重要功能的开放程度会因“人”而异。对，优质的接口只会开放给腾讯的儿子们（滴滴呀、京东呀）微信从来就是一眼不合就封杀，优步就是很好的案例。官方解释是优步涉嫌诱导，滴滴同样被禁过。利益面前还讲道理？反正我是不信的。腾讯的投资覆盖各个行业，一旦腾讯掌握了应用分发入口，给儿子们一些小小的甜头，应该不是什么大事儿吧。有人说AppStore也有很多限制，但至少苹果并没有像腾讯这样大量的投资消费级App，直接产生利益冲突的点并不多。话说回来，这点创业者是不用考虑的，暂时，你的产品和创意，在微信眼里还是个蝼蚁。。。你不用担心受到不公正的对待。如果真有一天你被微信封杀了，只要不是因为违规内容，那么你应该高兴，然后迅速炒作一波…….很多做Web的朋友尝试在小程序里写div、ul等标签，别试了，没效果，包括JQUERY在内的DOM操作库，小程序内是不能运行的。小程序本质是JS+ReactNative，对RN底层做了重构，已经和dom说拜拜了。 下面是详细的安装步骤。win10下测试通过以下是安装步骤：按操作系统下载相应开发工具版本 windows 64位 windows 32位 mac 小程序示例组件demo下载双击安装打开微信web开发者工具添加一个项目，如图填写项目信息 注意AppId这里选择“无AppId”,AppID只有内测用户才有，无AppId在目前有功能限制，比如不能发布项目到手机微信中预览。点击“添加项目”按钮后，将创建一个小程序项目, 工具已经为你创建了一个demo —– Hello World开发者工具功能区域介绍工具左侧分别有编辑、调试、项目调试区按钮，分别解释3个区域的作用.。编辑： 是你写代码的地方，左侧的文件目录是微信为你创建的一个项目基础骨架，你可以在这个骨架上编写自己的业务代码。当我们编写完代码后，点击编辑视图左下角的“编译”即可进行调试和运行（当点击“编译后”，工具视图会自动跳转到第二个“调试”视图）调试: 是你调试代码的地方。整个界面同Chrome的调试工具一模一样（应该是内嵌了WebKit内核），相信有Web开发经验的同学很快就能上手。F8 运行到下一个断点、F10 单步运行、Ctrl+/ 注释代码。解释一下“调试”视图下，顶部的六个Tab栏（Console、Sources、Network、Storage、AppData、Wxml）： Console： 工具的输出区域，在程序中调用 console.log(‘测试一下console’), 可在这里输出自定义调试信息。同时，这里也是工具遇到异常和发出警告的信息输出区域。见图：  Sources: 源代码显示区域，这里你可以打断点并调试代码。Sources Pannel 用于显示当前项目的脚本文件，同浏览器开发不同，微信小程序框架会对脚本文件进行编译的工作，所以在 Sources Pannel 中开发者看到的文件是经过处理之后的脚本文件，同编辑区域的代码有稍许的差异，比如开发者的代码都会被包裹在 define 函数中，并且对于 Page 代码，在尾部会有 require 的主动调用。  Network: 用于观察和显示 网络的request 和 socket 的请求情况   Storage: 如果你在程序中使用了 wx.setStorage 或者 wx.setStorageSync 后，在这里将会显示你的数据存储情况。是的，小程序支持本地缓存数据。   AppData: 用于显示当前项目当前时刻 appdata 具体数据。可以在这里管理应用程序中的各类变量（不同于Storage中的缓存变量，只有调用wx.setStorage 或者 wx.setStorageSync 的数据才会出现在Storage中）。在这，你可以随时修改变量，工具将把变量改变在左侧预览视图中实时显示。我们可以看到，AppData 以页面（pages/index/index）作为分组单位，每个页面只会显示自己的AppData，非常的清晰。 Wxml：将Wxml标签同预览界面实时关联，在这里可以看到真实的页面结构以及结构对应的 wxss 属性，同时可以通过修改对应 wxss 属性，在模拟器中实时看到修改的情况。通过调试模块左上角的选择器，还可以快速找到页面中组件对应的 wxml 代码。最后说下“项目”这个功能区块儿， 项目实际上是用来上传和预览项目的。微信要求所有发布的小程序都必须审核，所以需要在这里将小程序上传（应该是类似于AppStore，但肯定不是AppStore的发布模式，苹果应该不会允许。小程序目前同用户的接触方式还是未知数，而这恰恰是最重要的一块儿）。如果你没有被内测邀请，这里你是不可以上传和预览项目的，也不可以真机运行小程序，所以真正的体验相对于原生App还是未知数。目前阶段，你只能熟悉一下小程序的API，以便在公测后迅速拿出自己的产品，抢夺第一波红利。总体来说，小程序的大概开发模式和模型 已经暴露，其本质是JS+RN，很多人说JavaScript程序员的春天来了，其实小程序的体系和Web开发还是有很多区别的。微信言下之意是要抛弃你们熟悉的DOM采用他的组件体系，更熟悉这种组件式开发的不是传统的Web前端，而是iOS开发人员（更早点你可以追溯到Flex和SilverLight），我本人是不喜欢这种非JS原生的组件式开发的，自由度会受限。后续，我会持续更新小程序的开发例子和教程，尽快帮助大家上手开发业务和产品。你现在需要做的，就是静心想想，我应该开发一个什么样的产品？"}
{"title": "zhi_chao：小程序进阶实战进阶：豆瓣电影demo布局搭建 ", "author": "天下雪", "pub_time": "2016-10-20 10:44", "content": "我们创建起了小程序项目，并粗浅的了解了小程序的外部项目结构，了解了 js，wxml，wxss都最基本运用，现在我们在进行循序渐进的深入探究，如何制作真实项目。先看效果图： 分析步骤：1、讲头部的视图滑动，简单2、讲底部的导航栏，简单3、讲中间的内容显示，中等4、讲JS逻辑实现。复杂难度等级的划分只局限于本文，不联系实际开发。 1、头部视图滑动，实例图：  准备工作先做好，创建一个项目，把系统自带的都删了 只留外层目录，内层文件都删了。  然后在pages中添加一个movie目录作为首页，分别在创建，js  \\  wxml  \\  wxss. ,并在app.json中注册 好了，现在我们开始编写wxml与js文件，首先我们确定头部显示要用什么组件，先看官方文档中的swiper-view控件（滑块视图组件）就用它了 在文档中找到这段并代码复制到 wxml中去 （复制后别忘了 Ctrl+s 保存） 然后复制这段代码到 js 文件去  好了我们可以去调试页面看看变化，用鼠标可以滑动，但它的显示有瑕疵有留白，我们去wxml中做一点改动。 在wxml中把width和height 两个属性去掉 ，改为： style = \"width:100%\"  。  {{}}中的内容是什么，看后面注解。 现在我们在去js中，把视图改为自动跳转的。 仔细看注释！ 豁然开朗了吧，文档也理解了吧! 完成以上步骤后，一个滑动视图算是初步的做好了，以后要做深入也只是把视图改为动态获取图片，而不是像现在这样指定了静态的链接，是不正确的， 当然你也可以做一些稀奇古怪的滑动视图没人拦你。从这里我们可以发现微信小程序开发，给我们带来的方便与高效，只要摸清楚文档，一个程序还是挺容易搭建的。  2、底部导航栏：打开官方开发文档文档配置篇 把这段复杂过来，要注意我们要把路径改为刚刚创建的movie文件目录，然后去网上找一下log资源放到image文件中去.在文档配置篇中找一下iconPath和selectedIconPath看看他们是干嘛的！底部导航栏就完成了，看下面的代码也能不难。 完成后的效果：  现在开始进入下一个阶段，先看效果图  简单的分析下，一个图片控件image，在加一个文字控件text，接下来的排版就需要交给wxss和<view>进行配合搭建，而不是单纯的只使用image和text，使用<view包裹，在利用wxss进行编排在刚刚的，image目录中，放一张图片进去先，我放了 “我老婆的照片”MD美死了！！！ 然后在wxss中做一些准备 ，其实这步骤是不对的，但如果联系wxml边写边做wxss的样式，要截的图就多的离谱了，所以我想，直接给wxml和wxss写好的布局，让你自己去琢磨分析也有相同的效果，毕竟我已经给出很详细的注解了，不至于看晕。/** 占满全屏**/.content{height: 100%;}/** 将图片与文字左右分开 **/.movie{display: flex;flex-direction: row;}/** 设置图片大小 **/.pic image{width: 100px;height: 150px;}/** 设置与左边图片的间距**/.movie-info{padding-left: 20px ;}/** 文字大小与行高 **/.base-info{font-size: 12px;padding-top: 20px;line-height: 20px;}/** 分割线 **/.hr{height: 2px;width: 100%; border-top: wheat solid 1px;border-bottom: wheat solid 1px;opacity: 0.2;}wxml中的布局，就让您自己去打吧，不然学习就失去效果了，要注意的是我的<view> 是上下呼应的为了能让你看清楚，它的结束语句在哪里，占满全屏的view它的结束语句必须包裹所有内容。我把要讲的内容放在注解里了，写完保存直接去调试页面看效果。 粗略的布局总算是搭建好了，后面就是联系API获取数据，在js中做一些逻辑操作了。 以上归纳概述：<view> 用来做排版， 组件负责接收数据并显示。现在要开始编写JS文件了，这里就有点麻烦，毕竟代码量还挺多的，你可以先休息一会儿，把wxml和wxss先消化一下"}
{"title": "zhi_chao：小程序进阶实战进阶：豆瓣电影demoJS逻辑篇 ", "author": "天下雪", "pub_time": "2016-10-20 11:08", "content": "双大括号是{{}}用来JS和wxml绑定事件的，比如，数据更新，显示规则，等等的一些有规则有章法的操作。那么我们就需要引用这种机制，为我们的image和text控件做数据更新的操作。很好知道这点，后面的事情都交给JS去完成。现在开始，分析步骤，（前面三步为一体，第四步则分出来讲。）1、首先要有一个函数用来向网络发送请求这一步看官方文档发送请求2、关注文档中的三个关键字，url、header、success,url，就不多说了网络请求，不了解的必须先了解一下header，不熟悉HTTP协议的朋友，在看到文档中这个属性时一定会迷惑看的云里雾里的，他是将网页中的内容进行解析比如文档中的 header 方法中的代码：'Content-Type':'application/json' 是把内容解析为json格式的，如果把它换成'Content-Type':'application/xml' 那么它就会将网页的内容解析为xml格式的，现在你应该明白了，json是微信自己指定的文件格式，我们按照它的写法就可以了，so等会直接复制过来使用。success，读取数数据用的函数、（看文档时看他的类型Function）3、（这一步的操作对后面的理解有些许帮助）豆瓣电影API 我们分别要使用到他的 ， 正在热映 ，Top250 , 电影搜索，三个接口。https://api.douban.com/v2/movie/in_theaters 查看接口 以正在热映为列 由于此页面的内容太复杂，我们可以做一些简化打开此链接，按F12出现调试框，将页面中的所有内容复制，而后在调试框中输入 var a = 将复制的内容粘贴在等号后面，回车，然后输入 a 回车，现在此页面的内容就有条理了。4、有了以上步骤思路，最后要想到，数据的读取，以及数据格式处理（这里的格式化与header不同，我们是将数据格式化编排给用户看的）。so：我们需要两个函数，一个用来循环遍历读取网络数据，另一个则把数据格式化。由于这两个函数的也可以为后面top250的页面使用，所以我使用封装把他们俩封装起来供后面的逻辑使用。5、把数据在wxml中进行关联。有了这四步的思路，我们开始看JS代码的实现。（我怕你已经晕了！别急有了前面的步骤做铺垫我想你看起代码来会更得心应手。）由于前三步相对简单所以先从第四步的两个函数开始说 ：在Utils中创建subjectUtills.js (文件名不是固定的。)  接下来在 写第一个循环获取数据的函数。  现在来写数据格式的函数，由于代码有点多就想着给你节约点时间下面给出可复制的文字。// 获取数据并格式function provessSubject( subject ) {//电影名var title = subject.title;//导演信息var directors = subject.directors;var directorStr = \"\";for( var index in directors ) {directorStr = directorStr + directors[ index ].name + \" / \";}if( directorStr != \"\" ) {directorStr = directorStr.substring( 0, directorStr.length - 2 );}//演员信息var casts = subject.casts;var castStr = \"\";for( var index in casts ) {castStr = castStr + casts[ index ].name + \" / \";}if( castStr != \"\" ) {castStr = castStr.substring( 0, castStr.length - 2 );}//类型信息var genres = subject.genres;var genreStr = \"\";for( var index in genres ) {genreStr = genreStr + genres[ index ] + \" / \";}if( genreStr != \"\" ) {genreStr = genreStr.substring( 0, genreStr.length - 2 );}//发行的年份var year = subject.year;//将数据格式化var text = \"名称：\" + title + \"\\n导演:\" + directorStr + \"\\n演员:\" + castStr + \"\\n类型:\" + genreStr + \"\\n上映年份:\" + year + \"(中国大陆)\"//拿到格式化的数据subject.text = text;}模块化（封装） 最后不要忘记封装 完成了这两个函数，现在我们来写网络请求的逻辑代码 第五步，完成wxml中的数据关联。注意 {{item.images.medium}} 这串代码 和  {{item.text}} 后面细讲。这里添加了block循环和loading组件。 讲一下{{item.images.medium}} ， 而 {{item.text}}应该不用多讲就是我们格式化的数据。使用第三步的操作 你会得到这样的页面，看了之后你应该就不明觉厉了， 首页差不多就写好了现在看一下效果怎么样。 写到这里一个展示区差不多就写好了，后面还要继续深入。"}
